---
title: "LS Insurance"
author: "Sergio Fernández Serrano"
date: "`r format(Sys.Date(), '%d de %B de %Y')`"
output:
  html_document:
    code_folding: hide
    theme: readable
    number_sections: yes
    toc: yes
    toc_depth: 2
    toc_float: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
	echo = TRUE,
	include = TRUE,
	warning = FALSE,
	message = FALSE,
	fig.align = "center",
	out.width = "90%"
)
```

![](LS.jpg)

# Introducción y definición de objetivos

Nos complace presentar un innovador proyecto de machine learning enfocado en la transformación digital del sector asegurador. El objetivo principal es abordar dos desafíos clave en la industria; el análisis exploratorio de los datos de la compañía aseguradora LS y la creación de modelos predictivos para estimar el coste de siniestros y clasificarlos de manera eficiente.

En primer lugar, el análisis exploratorio nos permitirá identificar patrones, tendencias y posibles anomalías en el conjunto de datos proporcionado por la compañía aseguradora. Mediante técnicas avanzadas de visualización y análisis estadístico, seremos capaces de extraer información valiosa y descubrir oportunidades de mejora en la gestión de riesgos y la toma de decisiones.

En segundo lugar, el desarrollo de modelos predictivos basados en machine learning nos permitirá anticiparnos a los costes de siniestros y clasificarlos de manera más precisa. Estos modelos, entrenados con un vasto conjunto de datos históricos, nos brindarán una herramienta eficaz para optimizar la evaluación del riesgo, la asignación de recursos y el diseño de estrategias de prevención.

Con la implementación de este proyecto, aspiramos a impulsar la eficiencia operativa y la rentabilidad de la compañía aseguradora, así como mejorar la calidad del servicio ofrecido a sus clientes. Estamos convencidos de que la adopción de tecnologías de machine learning y el análisis de datos en el sector asegurador es crucial para mantenerse competitivo en un mercado cada vez más exigente y en constante evolución.

**¡Síguenos en este apasionante viaje hacia la digitalización e innovación en el mundo de los seguros!**

\

# Análisis exploratorio inicial

```{r}
paste(R.Version()$version.string)
```

```{r}
library(readr) # Lectura de datos especialmente CSVs
library(readxl) # Lectura de datos especialmente Excel (.xls y .xlsx)
library(dplyr) # Para manipulación y transformación de datos en R
library(tidyr) # Permite manipular la forma de conjuntos de datos en R
library(DT) # Mejora el trabajo con dataframes
library(kableExtra) # Mejora y estiliza tablas
library(ggplot2) # Para gráficos en R
library(GGally) # Extensión de ggplot2, facilitando la visualización de pares y combinaciones de datos
library(gridExtra) # Herramientas para trabajar con múltiples gráficos de ggplot2
library(cowplot) # Para mejoras de gráficos de ggplot2
library(ggcorrplot) # Visualización de matrices de correlación usando ggplot2
library(gmodels) # Varios modelos matemáticos y herramientas estadísticas
library(ggfortify) # Extensión de ggplot2 con funciones para visualizar resultados de varios modelos estadísticos
library(caret) # Construcción y evaluación de modelos de aprendizaje automático
library(scales) # Herramientas de escalado y formateo de datos
library(class) # Funciones para clasificación
library(distances) # Herramientas para trabajar con distancias y métricas
library(visreg) # Visualización de modelos de regresión
library(rpart) # Paquete de partición recursiva y árboles de regresión
library(rpart.plot) # Visualización de árboles rpart
library(rattle) # Interfaz gráfica y utilidades para minería de datos
library(randomForest) # Paquete que implementa el algoritmo de Random Forest para clasificación y regresión
library(e1071) # Funciones de estadística y aprendizaje automático, incluye máquinas de soporte vectorial
library(pROC) # Herramientas para visualizar y comparar ROC curves
library(cluster) # Métodos de clustering
library(tidyverse) # Colección de paquetes relacionados con la manipulación y visualización de datos (incluye ggplot2, dplyr, tidyr ...)
library(stringr) # Manipulación de cadenas de caracteres
library(Metrics) # Funciones para calcular métricas de modelos predictivos
library(factoextra) # Herramientas de visualización para resultados de descomposición
library(NbClust) # Determina y proporciona el número óptimo de clusters por diferentes métodos

```

## Lectura y preparación de los datos

Leemos el dataset original.

```{r}
LS_original <- read_excel("LS.xlsx")
```

```{r}
LS <- LS_original %>% mutate_at(vars("f_ocurrencia", "f_declaracion", "f_cierre"), as.Date)
```

```{r}
str(LS)
```

```{r}
summary(LS)
```

```{r}
head(LS, 10) %>%
  kbl() %>%
  kable_material(c("striped", "hover")) %>%
  scroll_box(width = "100%", height = "350px")
```

```{r}
dim(LS)
```

\

El dataset contiene **143.930** observaciones (correspondientes a siniestros cada una) y **15** variables (de las cuales son *8* cualitativas, *4* cuantitativas y *3* fechas).

A continuación, la descripción de cada una de las variables:

-   **siniestro**: número identificador del siniestro.

-   **producto**: producto al que va a asociado el siniestro y que tiene una serie de coberturas y garantías en las cuales no entramos.

-   **ramo**: ramo asegurador al que se asigna el siniestro. DJ (defensa jurídica) o PP (pérdida pecuniaria)

-   **tipo**: tipo de seguro en función de la manera en la que se adquiere el riesgo, puede ser adquirido de manera directa a través de la venta directa por la aseguradora (SD - seguro directo) o puede ser un riesgo aceptado si es un riesgo que se adquiere de otra compañía de seguros (RA - reaseguro aceptado).

-   **f_ocurrencia**: fecha en la que ocurre el siniestro.

-   **f_declaracion**: fecha en la que el siniestro es comunicado a la compañía de seguros y es abierto.

-   **f_cierre**: fecha en la que termina el siniestro y es cerrado el expediente.

-   **estado**: estatus en el que se encuentra el siniestro (abierto, cerrado, reaperturado...)

-   **cobertura**: nombre y tipo de cobertura siniestrable que aplica en el siniestro y por la que la compañía proporciona una cobertura al asegurado.

-   **prov_inicial_cob**: provisión con la que se abre el siniestro.

-   **prov_cob**: provisión actual que tiene el siniestro en el momento del análisis a 31/12/2022.

-   **pago_total_cob**: cuantía total que se ha pagado hasta el momento (31/12/2022) en el siniestro.

-   **coste_total_cob**: sumatorio de provision_cobertura_vl + importe_pago_total_cobertura_vl hasta el momento (31/12/2022) en el siniestro.

-   **medio**: vía mediante la cual se ha proporcionado la cobertura. En este caso, como se tratan de defensa jurídica, es la vía jurídica por la que se ha procedido en el siniestro (acuerdo extrajudicial, juicio con abogado de la red interna o juicio con abogado particular)

-   **materia**: asunto principal que motiva el siniestro y que motiva el expediente.

\

## Tratamiento de datos faltantes

No hacemos tratamiento de datos faltantes pues nuestro conocimiento del negocio nos dice que es normal que haya datos faltantes en la variable **f_cierre** ya que puede haber siniestros en estado abierto.

\

## División del dataset

Dividimos el dataset en train, test y validation y posteriormente comprobamos que número de observaciones tiene cada una de las partes respecto al dataset total.

```{r}
set.seed(108)
numero_total = nrow(LS)
# Porcentajes de train, test y validation
w_train = .5
w_test = .25
w_validation = 1 - (w_train + w_test)
# Todos los índices
indices = seq(1:numero_total) 
# Muestreo
indices_train = sample(1:numero_total, numero_total * w_train)
indices_test = sample(indices[-indices_train], numero_total * w_test)
indices_validation = indices[-c(indices_train,indices_test)]
# Agrupamos
LS_train = LS[indices_train,]
LS_test = LS[indices_test,]
LS_validation = LS[indices_validation,]
```

```{r}
nrow(LS)
nrow(LS_train)
nrow(LS_test)
nrow(LS_validation)
```

\
\

# Análisis univariante

## Análisis de variables cualitativas

\

**PRODUCTO**

```{r}
merge(setNames(as.data.frame(table(LS_train$producto)), c("producto", "count")),
      setNames(as.data.frame(round(prop.table(table(LS_train$producto))*100, 2)), c("producto", "prop (%)"))
) %>%
  arrange(desc(count)) %>%
  kbl() %>%
  kable_material(c("striped", "hover")) %>%
  scroll_box(width = "100%", height = "350px")
```

\

**RAMO**

```{r}
merge(setNames(as.data.frame(table(LS_train$ramo)), c("ramo", "count")),
      setNames(as.data.frame(round(prop.table(table(LS_train$ramo))*100, 2)), c("ramo", "prop (%)"))
) %>%
  arrange(desc(count)) %>%
  kbl() %>%
  kable_material(c("striped", "hover")) %>%
  scroll_box(width = "100%", height = "auto")
```

\

**TIPO**

```{r}
merge(setNames(as.data.frame(table(LS_train$tipo)), c("tipo", "count")),
      setNames(as.data.frame(round(prop.table(table(LS_train$tipo))*100, 2)), c("tipo", "prop (%)"))
) %>%
  arrange(desc(count)) %>%
  kbl() %>%
  kable_material(c("striped", "hover")) %>%
  scroll_box(width = "100%", height = "auto")
```

\

**ESTADO**

```{r}
merge(setNames(as.data.frame(table(LS_train$estado)), c("estado", "count")),
      setNames(as.data.frame(round(prop.table(table(LS_train$estado))*100, 2)), c("estado", "prop (%)"))
) %>%
  arrange(desc(count)) %>%
  kbl() %>%
  kable_material(c("striped", "hover")) %>%
  scroll_box(width = "100%", height = "auto")
```

\

**COBERTURA**

```{r}
merge(setNames(as.data.frame(table(LS_train$cobertura)), c("cobertura", "count")),
      setNames(as.data.frame(round(prop.table(table(LS_train$cobertura))*100, 2)), c("cobertura", "prop (%)"))
) %>%
  arrange(desc(count)) %>%
  kbl() %>%
  kable_material(c("striped", "hover")) %>%
  scroll_box(width = "100%", height = "350px")
```

\

**MEDIO**

```{r}
merge(setNames(as.data.frame(table(LS_train$medio)), c("medio", "count")),
      setNames(as.data.frame(round(prop.table(table(LS_train$medio))*100, 2)), c("medio", "prop (%)"))
) %>%
  arrange(desc(count)) %>%
  kbl() %>%
  kable_material(c("striped", "hover")) %>%
  scroll_box(width = "100%", height = "auto")
```

\

**MATERIA**

```{r}
merge(setNames(as.data.frame(table(LS_train$materia)), c("materia", "count")),
      setNames(as.data.frame(round(prop.table(table(LS_train$materia))*100, 2)), c("materia", "prop (%)"))
) %>%
  arrange(desc(count)) %>%
  kbl() %>%
  kable_material(c("striped", "hover")) %>%
  scroll_box(width = "100%", height = "350px")
```

\

```{r}
# PLOT PRODUCTO
# Paso 1: Sumarizar y ordenar los datos
LS_train_primeros15 <- LS_train %>%
  group_by(producto) %>%
  summarize(count = n()) %>%
  arrange(-count) %>%
  slice(1:15) # Paso 2: Limitar a los 15 productos más frecuentes

# Paso 2: Gráfico
plot_producto <- ggplot(LS_train_primeros15, aes(x = reorder(producto, count), y = count)) + 
                    geom_bar(stat = "identity", fill = "#009494") +
                    coord_flip() +
                    labs(x = "producto", y = "Nº producto", title = "Producto") +
                    theme(plot.title = element_text(hjust = 0.5))
                    
                    

# PLOT RAMO                    
plot_ramo <- ggplot(LS_train, aes(ramo)) +
                geom_bar(fill = "#009494") +
                labs(x = "ramo", y = "Nº ramo", title = "Ramo") +
                theme(plot.title = element_text(hjust = 0.5))



# PLOT TIPO
plot_tipo <- ggplot(LS_train, aes(tipo)) +
                geom_bar(fill = "#009494") +
                labs(x = "tipo", y = "Nº tipo", title = "Tipo") +
                theme(plot.title = element_text(hjust = 0.5))



# PLOT ESTADO
# Paso 1: Calcular el número de ocurrencias para cada 'estado'
estado_counts <- LS_train %>% 
  group_by(estado) %>% 
  summarise(n = n()) %>% 
  arrange(-n)

# Paso 2: Usar esa información para reordenar la variable 'estado' en el dataframe
LS_train$estado <- factor(LS_train$estado, levels = estado_counts$estado)

# Paso 3: Crear el gráfico
plot_estado <- ggplot(LS_train, aes(estado)) +
                  geom_bar(fill = "#009494") +
                  labs(x = "estado", y = "Nº estado", title = "Estado") +
                  theme(plot.title = element_text(hjust = 0.5), 
                        axis.text.x = element_text(angle = 15, hjust = 1))
                  


# PLOT MEDIO
# Paso 1: Calcular el número de ocurrencias para cada 'medio'
medio_counts <- LS_train %>% 
  group_by(medio) %>% 
  summarise(n = n()) %>% 
  arrange(-n)

# Paso 2: Usar esa información para reordenar la variable 'medio' en el dataframe
LS_train$medio <- factor(LS_train$medio, levels = medio_counts$medio)

# Paso 3: Crear el gráfico
plot_medio <- ggplot(LS_train, aes(medio)) +
                 geom_bar(fill = "#009494") +
                 labs(x = "medio", y = "Nº medio", title = "Medio") +
                 theme(plot.title = element_text(hjust = 0.5), 
                       axis.text.x = element_text(angle = 15, hjust = 1))
                 
                 

# PLOT MATERIA                 
# Paso 1: Calcular el número de ocurrencias para cada 'materia'
materia_counts <- LS_train %>% 
  group_by(materia) %>% 
  summarise(n = n()) %>% 
  arrange(n)

# Paso 2: Usar esa información para reordenar la variable 'materia' en el dataframe
LS_train$materia <- factor(LS_train$materia, levels = materia_counts$materia)

# Paso 3: Crear el gráfico
plot_materia <- ggplot(LS_train, aes(x = materia)) +
                   geom_bar(fill = "#009494") +
                   coord_flip() + 
                   labs(x = "materia", y = "Nº materia", title = "Materia") +
                   theme(plot.title = element_text(hjust = 0.5))             
```

```{r}
grid.arrange(plot_producto,
             plot_materia,
             ncol=2)
```

\

Para la variable producto sólo representamos los 15 primeros ya que a partir de ahí son muchos los productos pero pocos los siniestros por producto. Se observa como un producto destaca ampliamente sobre el resto, en torno al 47% de los siniestros de esta compañía son del producto CROH.

En cuanto a la materia, destaca ampliamente todo lo que tiene que ver con inmuebles, el 50% de los siniestros.

```{r}
grid.arrange(plot_ramo, 
             plot_tipo,
             ncol=2)
```

Casi el 98% de los siniestros son del ramo de Defensa Jurídica, ramo CORE de LS Insurance y tan sólo el 2% de Pérdidas Pecuniarias.

Algo parecido sudece con el tipo de seguro ya que el 87% son de RA (reaseguro aceptado) y sólo un 13% aproximadamente de SD (seguro Directo). Esto nos indica que la mayor parte de la siniestralidad de la compañía procede de la aceptación de riesgo de otras compañías aseguradoras y no del riesgo que vende LS de manera directa.

```{r}
grid.arrange(plot_estado, 
             plot_medio, 
             ncol=2)
```

El 90% de los siniestros están terminados y a priori no se van a producir cambios en ellos por lo que los datos finales de estos contituyen de manera bastante fiel la realidad de la siniestralidad de la compañía y nos facilitará en gran medida la tarea de clasificar y predecir costes de siniestros.

Por otro lado es relevante apreciar que en al rededor de un 72% de los siniestros terminan siendo gestionados de manera extrajudicial, un 15% en juicios llevados por letrados de la red propia de LS Insurance y un 13% acaban en manos de abogados externos que comunmente provocan un incremento en el coste del siniestro ya que no son llevados por personal interno.

\

\****No se realiza gráfico de la variable cobertura por cuestión estética debido a la gran cantidad de coberturas existentes, casi 200 distintas, y porque no tiene mucho sentido ya que entre ellas las diferencias son excasas***

\

## Análisis de variables temporales

\

```{r}
# Extraer el año y convertirlo en una variable categórica
LS_train <- LS_train %>%
  mutate(year_ocurrencia = as.factor(lubridate::year(f_ocurrencia)),
         year_declaracion = as.factor(lubridate::year(f_declaracion)),
         year_cierre = as.factor(lubridate::year(f_cierre)))
```


**FECHA OCURRENCIA**

```{r}
tabla_ocurrencia <- LS_train %>%
  group_by(year_ocurrencia) %>%
  summarise(count = n()) %>%
  mutate(prop = round((count / sum(count)) * 100, 2)) %>%
  arrange(desc(count))

tabla_ocurrencia %>%
  kbl(col.names = c("year", "count", "prop (%)")) %>%
  kable_material(c("striped", "hover")) %>%
  scroll_box(width = "100%", height = "350px")
```

```{r}
# PLOT AÑO OCURRENCIA
plot_year_ocurrencia <- ggplot(LS_train, aes(x = year_ocurrencia)) +
  geom_line(stat = 'count', aes(group = 1), color = "#009494") +
  labs(x = "Año de ocurrencia", y = "Nº de siniestros", title = "Siniestros por año de ocurrencia") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5))
```


\

**FECHA DECLARACIÓN**

```{r}
tabla_declaracion <- LS_train %>%
  group_by(year_declaracion) %>%
  summarise(count = n()) %>%
  mutate(prop = round((count / sum(count)) * 100, 2)) %>%
  arrange(desc(count))

tabla_declaracion %>%
  kbl(col.names = c("year", "count", "prop (%)")) %>%
  kable_material(c("striped", "hover")) %>%
  scroll_box(width = "100%", height = "350px")
```

```{r}
# PLOT AÑO DECLARACIÓN
plot_year_declaracion <- ggplot(LS_train, aes(x = year_declaracion)) +
  geom_line(stat = 'count', aes(group = 1), color = "#009494") +
  labs(x = "Año de declaración", y = "Nº de siniestros", title = "Siniestros por año de declaración") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5))
```

\

**FECHA CIERRE**

```{r}
tabla_cierre <- LS_train %>%
  group_by(year_cierre) %>%
  summarise(count = n()) %>%
  mutate(prop = round((count / sum(count)) * 100, 2)) %>%
  arrange(desc(count))

tabla_cierre %>%
  kbl(col.names = c("year", "count", "prop (%)")) %>%
  kable_material(c("striped", "hover")) %>%
  scroll_box(width = "100%", height = "350px")
```

```{r}
# PLOT AÑO CIERRE
plot_year_cierre <- ggplot(LS_train, aes(x = year_cierre)) +
  geom_line(stat = 'count', aes(group = 1), color = "#009494") +
  labs(x = "Año de cierre", y = "Nº de siniestros", title = "Siniestros por año de cierre") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5))
```

\

```{r}
# GRÁFICOS JUNTOS POR AÑO
# Primero hay que modificar el dataframe para que las fechas estén en una sola columna y tener otra columna que identifique el tipo de fecha
LS_train_long <- LS_train %>%
  select(siniestro, year_ocurrencia, year_declaracion, year_cierre) %>%
  gather(key = "Tipo de Fecha", value = "Año", -siniestro)

plot_fechas_año <- ggplot(LS_train_long, aes(x = Año, group = `Tipo de Fecha`)) +
  geom_line(stat = 'count', aes(color = `Tipo de Fecha`)) +
  labs(x = "Año", y = "Nº de siniestros", title = "Siniestros por año según tipo de fecha") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5)) +
  scale_color_manual(values = c("year_ocurrencia" = "blue", "year_declaracion" = "green", "year_cierre" = "red"),
                     name = "Tipo de Fecha")

print(plot_fechas_año)
```

Podemos observar la tendencia de que año tras año el número de siniestros que ocurren y son declaran por parte de los asegurados es creciente y con una pendiente bastante acentuada. 

Esto puede ser por varios motivos pero uno de los principales en este negocio es el crecimiento de la cartera y la asunción de nuevos riesgo con el correspondiente crecimiento de las primas devengadas anuales. Este hecho no lo podemos comprobar ya que el dataset carece de datos relativos a primas, no obstante, nuestro conocimiento del negocio nos hace pensar que es así.

Importante a tener en cuenta es que los crecimientos de cartera y en número de siniestros no siempre son proporcionales, no todas las carteras (productos) tienen los mismo comportamientos y en el estudio de la rentabilidad de las mismas hay que tener en cuenta la rentabilidad o el ratio de siniestralidad de las mismas.

```{r}
# PLOT MES OCURRENCIA
LS_train$mes_ocurrencia <- lubridate::month(LS_train$f_ocurrencia, label = TRUE)

plot_mes_ocurrencia <- ggplot(LS_train, aes(mes_ocurrencia)) + 
  geom_bar(fill = "#009494") +
  labs(x = "Mes de ocurrencia", y = "Nº de siniestros", title = "Distribución de siniestros ocurridos por mes") +
  theme(plot.title = element_text(hjust = 0.5))



# PLOT MES DECLARACIÓN
LS_train$mes_declaracion <- lubridate::month(LS_train$f_declaracion, label = TRUE)

plot_mes_declaracion <- ggplot(LS_train, aes(mes_declaracion)) + 
  geom_bar(fill = "#009494") +
  labs(x = "Mes de declaración", y = "Nº de siniestros", title = "Distribución de siniestros declarados por mes") +
  theme(plot.title = element_text(hjust = 0.5))



# PLOT MES CIERRE
LS_train$mes_cierre <- lubridate::month(LS_train$f_cierre, label = TRUE)

plot_mes_cierre <- ggplot(LS_train, aes(mes_cierre)) + 
  geom_bar(fill = "#009494") +
  labs(x = "Mes de cierre", y = "Nº de siniestros", title = "Distribución de siniestros cerrados por mes") +
  theme(plot.title = element_text(hjust = 0.5))
```

```{r}
plot_mes_ocurrencia
plot_mes_declaracion
plot_mes_cierre
```

Respecto al número de siniestros ocurridos por mes hay una distribución más o menos homogénea pero se aprecia que hay menor número de siniestros en los meses donde hay mayores festividades, abril y diciembre, así como agosto por el periodo vacacional de verano. 

Esto se acentúa en los momentos de declarar siniestros por parte de los asegurados que normalmente esperan unos días en comunicarlos en caso de encontrarse en periodos estivales. Y pasa lo mismo en lo que respecta al cierre de siniestros por parte de los tramitadores de LS Insurance.

Intuímos un cierto patrón; los meses sin fiestas sube el número de siniestros ocurridos, declarados y cerrados mientras que por el contrario los meses con fiestas este número de siniestros baja.

```{r}
LS_train$dias_para_declarar <- as.numeric(difftime(LS_train$f_declaracion, LS_train$f_ocurrencia, units = "days"))
LS_train$dias_para_cerrar <- as.numeric(difftime(LS_train$f_cierre, LS_train$f_declaracion, units = "days"))

# Histograma con línea de densidad para días para declarar
plot_dias_para_declarar <- ggplot(LS_train, aes(x = dias_para_declarar)) +
  geom_histogram(aes(y = ..density..), fill = "#009494", bins = 50, alpha = 0.7) +
  geom_density(color = "green", size = 1.2) +
  labs(x = "Días para declarar", y = "Densidad", title = "Distribución de días para declarar") +
  theme(plot.title = element_text(hjust = 0.5))

# Histograma con línea de densidad para días para cerrar
plot_dias_para_cerrar <- ggplot(LS_train, aes(x = dias_para_cerrar)) +
  geom_histogram(aes(y = ..density..), fill = "#009494", bins = 50, alpha = 0.7) +
  geom_density(color = "red", size = 1.2) +
  labs(x = "Días para cerrar", y = "Densidad", title = "Distribución de días para cerrar") +
  theme(plot.title = element_text(hjust = 0.5))

# Para visualizar los gráficos, simplemente ejecuta sus nombres:
grid.arrange(plot_dias_para_declarar, 
             plot_dias_para_cerrar, 
             ncol=2)
```

```{r}
# Porcentaje de siniestros declarados antes de 90 días
porcentaje_declara_antes_90 <- mean(LS_train$dias_para_declarar < 90) * 100
porcentaje_declara_antes_365 <- mean(LS_train$dias_para_declarar < 365) * 100

# Porcentaje de siniestros cerrados antes de 90 días (excluyendo los NA)
porcentaje_cierra_antes_90 <- mean(LS_train$dias_para_cerrar < 90, na.rm = TRUE) * 100
porcentaje_cierra_antes_365 <- mean(LS_train$dias_para_cerrar < 365, na.rm = TRUE) * 100

cat(paste0("% de siniestros declarados antes de 90 días: ", round(porcentaje_declara_antes_90, 2), "%\n"))
cat(paste0("% de siniestros declarados antes de 365 días: ", round(porcentaje_declara_antes_365, 2), "%\n"))
cat(paste0("% de siniestros cerrados antes de 90 días: ", round(porcentaje_cierra_antes_90, 2), "%\n"))
cat(paste0("% de siniestros cerrados antes de 365 días: ", round(porcentaje_cierra_antes_365, 2), "%\n"))
```
Aunque el 77% de los siniestros se declara en los primeros 3 meses, exite un alto porcentaje de que el asegurado se demore en la comunicación de los mismos llegando a veces a tardar

HEADMAPS

\

## Análisis de variables cuantitativas

\

**PROVISIÓN INICIAL COBERTURA**

\

**PROVISIÓN COBERTURA**

\

**PAGO TOTAL COBERTURA**

\

**COSTE TOTAL COBERTURA**

\
\

# Análisis multivariante

\
\

# Procesado de variables cualitativas

\
\

# Modelo de regresión lineal

\
\

# Conclusiones preliminares

\
\

# Aprendizaje no supervisado

## K-Means

\
\

# Técnicas de reducción de la dimensionalidad

## PCA

\
\

# Aprendizaje supervisado

## GLM

## KNN

## DECISION TREES

## RANDOM FOREST

## SVM

\
\

# Evaluación y comparación de modelos

## K-fold Cross Validation

## N-fold Cross Validation

\
\

## Conclusiones

\

# Punto de corte ROC

\

# Deep Learning

\
\

# Explicabilidad

\
\

# Series Temporales


