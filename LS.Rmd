---
title: "LS Insurance"
author: "Sergio Fernández Serrano"
date: "`r format(Sys.Date(), '%d de %B de %Y')`"
output:
  html_document:
    code_folding: hide
    theme: readable
    number_sections: yes
    toc: yes
    toc_depth: 2
    toc_float: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
	echo = TRUE,
	include = TRUE,
	warning = FALSE,
	message = FALSE,
	fig.align = "center",
	out.width = "90%"
)
```

![](LS.jpg)

# Introducción y definición de objetivos

Nos complace presentar un innovador proyecto de machine learning enfocado en la transformación digital del sector asegurador. El objetivo principal es abordar dos desafíos clave en la industria; el análisis exploratorio de los datos de la compañía aseguradora LS y la creación de modelos predictivos para estimar el coste de siniestros y clasificarlos de manera eficiente.

En primer lugar, el análisis exploratorio nos permitirá identificar patrones, tendencias y posibles anomalías en el conjunto de datos proporcionado por la compañía aseguradora. Mediante técnicas avanzadas de visualización y análisis estadístico, seremos capaces de extraer información valiosa y descubrir oportunidades de mejora en la gestión de riesgos y la toma de decisiones.

En segundo lugar, el desarrollo de modelos predictivos basados en machine learning nos permitirá anticiparnos a los costes de siniestros y clasificarlos de manera más precisa. Estos modelos, entrenados con un vasto conjunto de datos históricos, nos brindarán una herramienta eficaz para optimizar la evaluación del riesgo, la asignación de recursos y el diseño de estrategias de prevención.

Con la implementación de este proyecto, aspiramos a impulsar la eficiencia operativa y la rentabilidad de la compañía aseguradora, así como mejorar la calidad del servicio ofrecido a sus clientes. Estamos convencidos de que la adopción de tecnologías de machine learning y el análisis de datos en el sector asegurador es crucial para mantenerse competitivo en un mercado cada vez más exigente y en constante evolución.

**¡Síguenos en este apasionante viaje hacia la digitalización e innovación en el mundo de los seguros!**

\

# Análisis exploratorio inicial

```{r}
paste(R.Version()$version.string)
```

```{r}
library(readr) # Lectura de datos especialmente CSVs
library(readxl) # Lectura de datos especialmente Excel (.xls y .xlsx)
library(dplyr) # Para manipulación y transformación de datos en R
library(tidyr) # Permite manipular la forma de conjuntos de datos en R
library(DT) # Mejora el trabajo con dataframes
library(kableExtra) # Mejora y estiliza tablas
library(ggplot2) # Para gráficos en R
library(GGally) # Extensión de ggplot2, facilitando la visualización de pares y combinaciones de datos
library(gridExtra) # Herramientas para trabajar con múltiples gráficos de ggplot2
library(cowplot) # Para mejoras de gráficos de ggplot2
library(ggcorrplot) # Visualización de matrices de correlación usando ggplot2
library(gmodels) # Varios modelos matemáticos y herramientas estadísticas
library(ggfortify) # Extensión de ggplot2 con funciones para visualizar resultados de varios modelos estadísticos
library(caret) # Construcción y evaluación de modelos de aprendizaje automático
library(scales) # Herramientas de escalado y formateo de datos
library(class) # Funciones para clasificación
library(distances) # Herramientas para trabajar con distancias y métricas
library(visreg) # Visualización de modelos de regresión
library(rpart) # Paquete de partición recursiva y árboles de regresión
library(rpart.plot) # Visualización de árboles rpart
library(rattle) # Interfaz gráfica y utilidades para minería de datos
library(randomForest) # Paquete que implementa el algoritmo de Random Forest para clasificación y regresión
library(e1071) # Funciones de estadística y aprendizaje automático, incluye máquinas de soporte vectorial
library(pROC) # Herramientas para visualizar y comparar ROC curves
library(cluster) # Métodos de clustering
library(tidyverse) # Colección de paquetes relacionados con la manipulación y visualización de datos (incluye ggplot2, dplyr, tidyr ...)
library(stringr) # Manipulación de cadenas de caracteres
library(Metrics) # Funciones para calcular métricas de modelos predictivos
library(factoextra) # Herramientas de visualización para resultados de descomposición
library(NbClust) # Determina y proporciona el número óptimo de clusters por diferentes métodos

```

## Lectura y preparación de los datos

Leemos el dataset original.

```{r}
LS_original <- read_excel("LS.xlsx")
```

```{r}
LS <- LS_original %>% mutate_at(vars("f_ocurrencia", "f_declaracion", "f_cierre"), as.Date)
```

```{r}
str(LS)
```

```{r}
summary(LS)
```

```{r}
head(LS, 10) %>%
  kbl() %>%
  kable_material(c("striped", "hover")) %>%
  scroll_box(width = "100%", height = "350px")
```

```{r}
dim(LS)
```

\

El dataset contiene **143.930** observaciones (correspondientes a siniestros cada una) y **15** variables (de las cuales son *8* cualitativas, *4* cuantitativas y *3* fechas).

A continuación, la descripción de cada una de las variables:

-   **siniestro**: número identificador del siniestro.

-   **producto**: producto al que va a asociado el siniestro y que tiene una serie de coberturas y garantías en las cuales no entramos.

-   **ramo**: ramo asegurador al que se asigna el siniestro. DJ (defensa jurídica) o PP (pérdida pecuniaria)

-   **tipo**: tipo de seguro en función de la manera en la que se adquiere el riesgo, puede ser adquirido de manera directa a través de la venta directa por la aseguradora (SD - seguro directo) o puede ser un riesgo aceptado si es un riesgo que se adquiere de otra compañía de seguros (RA - reaseguro aceptado).

-   **f_ocurrencia**: fecha en la que ocurre el siniestro.

-   **f_declaracion**: fecha en la que el siniestro es comunicado a la compañía de seguros y es abierto.

-   **f_cierre**: fecha en la que termina el siniestro y es cerrado el expediente.

-   **estado**: estatus en el que se encuentra el siniestro (abierto, cerrado, reaperturado...)

-   **cobertura**: nombre y tipo de cobertura siniestrable que aplica en el siniestro y por la que la compañía proporciona una cobertura al asegurado.

-   **prov_inicial_cob**: provisión con la que se abre el siniestro.

-   **prov_cob**: provisión actual que tiene el siniestro en el momento del análisis a 31/12/2022.

-   **pago_total_cob**: cuantía total que se ha pagado hasta el momento (31/12/2022) en el siniestro.

-   **coste_total_cob**: sumatorio de provision_cobertura_vl + importe_pago_total_cobertura_vl hasta el momento (31/12/2022) en el siniestro.

-   **medio**: vía mediante la cual se ha proporcionado la cobertura. En este caso, como se tratan de defensa jurídica, es la vía jurídica por la que se ha procedido en el siniestro (acuerdo extrajudicial, juicio con abogado de la red interna o juicio con abogado particular)

-   **materia**: asunto principal que motiva el siniestro y que motiva el expediente.

\

## Tratamiento de datos faltantes

No hacemos tratamiento de datos faltantes pues nuestro conocimiento del negocio nos dice que es normal que haya datos faltantes en la variable **f_cierre** ya que puede haber siniestros en estado abierto.

\

## División del dataset

Dividimos el dataset en train, test y validation y posteriormente comprobamos que número de observaciones tiene cada una de las partes respecto al dataset total.

```{r}
set.seed(108)
numero_total = nrow(LS)
# Porcentajes de train, test y validation
w_train = .5
w_test = .25
w_validation = 1 - (w_train + w_test)
# Todos los índices
indices = seq(1:numero_total) 
# Muestreo
indices_train = sample(1:numero_total, numero_total * w_train)
indices_test = sample(indices[-indices_train], numero_total * w_test)
indices_validation = indices[-c(indices_train,indices_test)]
# Agrupamos
LS_train = LS[indices_train,]
LS_test = LS[indices_test,]
LS_validation = LS[indices_validation,]
```

```{r}
nrow(LS)
nrow(LS_train)
nrow(LS_test)
nrow(LS_validation)
```

\
\

# Análisis univariante

## Análisis de variables cualitativas

\

**PRODUCTO**

```{r}
merge(setNames(as.data.frame(table(LS_train$producto)), c("producto", "count")),
      setNames(as.data.frame(round(prop.table(table(LS_train$producto))*100, 2)), c("producto", "prop (%)"))
) %>%
  arrange(desc(count)) %>%
  kbl() %>%
  kable_material(c("striped", "hover")) %>%
  scroll_box(width = "100%", height = "350px")
```

\

**RAMO**

```{r}
merge(setNames(as.data.frame(table(LS_train$ramo)), c("ramo", "count")),
      setNames(as.data.frame(round(prop.table(table(LS_train$ramo))*100, 2)), c("ramo", "prop (%)"))
) %>%
  arrange(desc(count)) %>%
  kbl() %>%
  kable_material(c("striped", "hover")) %>%
  scroll_box(width = "100%", height = "auto")
```

\

**TIPO**

```{r}
merge(setNames(as.data.frame(table(LS_train$tipo)), c("tipo", "count")),
      setNames(as.data.frame(round(prop.table(table(LS_train$tipo))*100, 2)), c("tipo", "prop (%)"))
) %>%
  arrange(desc(count)) %>%
  kbl() %>%
  kable_material(c("striped", "hover")) %>%
  scroll_box(width = "100%", height = "auto")
```

\

**ESTADO**

```{r}
merge(setNames(as.data.frame(table(LS_train$estado)), c("estado", "count")),
      setNames(as.data.frame(round(prop.table(table(LS_train$estado))*100, 2)), c("estado", "prop (%)"))
) %>%
  arrange(desc(count)) %>%
  kbl() %>%
  kable_material(c("striped", "hover")) %>%
  scroll_box(width = "100%", height = "auto")
```

\

**COBERTURA**

```{r}
merge(setNames(as.data.frame(table(LS_train$cobertura)), c("cobertura", "count")),
      setNames(as.data.frame(round(prop.table(table(LS_train$cobertura))*100, 2)), c("cobertura", "prop (%)"))
) %>%
  arrange(desc(count)) %>%
  kbl() %>%
  kable_material(c("striped", "hover")) %>%
  scroll_box(width = "100%", height = "350px")
```

\

**MEDIO**

```{r}
merge(setNames(as.data.frame(table(LS_train$medio)), c("medio", "count")),
      setNames(as.data.frame(round(prop.table(table(LS_train$medio))*100, 2)), c("medio", "prop (%)"))
) %>%
  arrange(desc(count)) %>%
  kbl() %>%
  kable_material(c("striped", "hover")) %>%
  scroll_box(width = "100%", height = "auto")
```

\

**MATERIA**

```{r}
merge(setNames(as.data.frame(table(LS_train$materia)), c("materia", "count")),
      setNames(as.data.frame(round(prop.table(table(LS_train$materia))*100, 2)), c("materia", "prop (%)"))
) %>%
  arrange(desc(count)) %>%
  kbl() %>%
  kable_material(c("striped", "hover")) %>%
  scroll_box(width = "100%", height = "350px")
```

\

```{r}
# PLOT PRODUCTO
# Paso 1: Sumarizar y ordenar los datos
LS_train_sorted15 <- LS_train %>%
  group_by(producto) %>%
  summarize(count = n()) %>%
  arrange(-count) %>%
  slice(1:15) # Paso 2: Limitar a los 15 productos más frecuentes

# Paso 3: Gráfico
plot_producto <- ggplot(LS_train_sorted15, aes(x = reorder(producto, count), y = count)) + 
                    geom_bar(stat = "identity", fill = "#009494") +
                    coord_flip() +
                    labs(x = "producto", y = "Nº producto", title = "Tipos producto") +
                    theme(plot.title = element_text(hjust = 0.5))
                    
                    
# PLOT RAMO                    
plot_ramo <- ggplot(LS_train, aes(ramo)) +
                geom_bar(fill = "#009494") +
                labs(x = "ramo", y = "Nº ramo", title = "Tipos ramo") +
                theme(plot.title = element_text(hjust = 0.5))


# PLOT TIPO
plot_tipo <- ggplot(LS_train, aes(tipo)) +
                geom_bar(fill = "#009494") +
                labs(x = "tipo", y = "Nº tipo", title = "Tipos tipo") +
                theme(plot.title = element_text(hjust = 0.5))


# PLOT ESTADO
plot_estado <- ggplot(LS_train, aes(estado)) +
                  geom_bar(fill = "#009494") +
                  labs(x = "estado", y = "Nº estado", title = "Estado") +
                  theme(plot.title = element_text(hjust = 0.5), 
                        axis.text.x = element_text(angle = 10, hjust = 1))
                  

# PLOT MEDIO
plot_medio <- ggplot(LS_train, aes(medio)) +
                 geom_bar(fill = "#009494") +
                 labs(x = "medio", y = "Nº medio", title = "Medio") +
                 theme(plot.title = element_text(hjust = 0.5), 
                       axis.text.x = element_text(angle = 10, hjust = 1))
                 
                 
# PLOT MATERIA                 
plot_materia <- ggplot(LS_train, aes(materia)) +
                   geom_bar(fill = "#009494") +
                   coord_flip() + 
                   labs(x = "materia", y = "Nº materia", title = "Materia") +
                   theme(plot.title = element_text(hjust = 0.5))             
```

```{r}
grid.arrange(plot_producto,
             plot_materia,
             ncol=2)
```

\

Para la variable producto sólo representamos los 15 primeros ya que a partir de ahí son muchos los productos pero pocos los siniestros por producto. Se observa como un producto destaca ampliamente sobre el resto, en torno al 47% de los siniestros de esta compañía son del producto CROH.

En cuanto a la materia, destaca ampliamente todo lo que tiene que ver con inmuebles, el 50% de los siniestros.

```{r}
grid.arrange(plot_ramo, 
             plot_tipo,
             ncol=2)
```

Casi el 98% de los siniestros son del ramo de Defensa Jurídica, ramo CORE de LS Insurance y tan sólo el 2% de Pérdidas Pecuniarias.

Algo parecido sudece con el tipo de seguro ya que el 87% son de RA (reaseguro aceptado) y sólo un 13% aproximadamente de SD (seguro Directo). Esto nos indica que la mayor parte de la siniestralidad de la compañía procede de la aceptación de riesgo de otras compañías aseguradoras y no del riesgo que vende LS de manera directa.

```{r}
grid.arrange(plot_estado, 
             plot_medio, 
             ncol=2)
```

El 90% de los siniestros están terminados y a priori no se van a producir cambios en ellos por lo que los datos finales de estos contituyen de manera bastante fiel la realidad de la siniestralidad de la compañía y nos facilitará en gran medida la tarea de clasificar y predecir costes de siniestros.

Por otro lado es relevante apreciar que en al rededor de un 72% de los siniestros terminan siendo gestionados de manera extrajudicial, un 15% en juicios llevados por letrados de la red propia de LS Insurance y un 13% acaban en manos de abogados externos que comunmente provocan un incremento en el coste del siniestro ya que no son llevados por personal interno.

\

\****No se realiza gráfico de la variable cobertura por cuestión estética debido a la gran cantidad de coberturas existentes, casi 200 distintas, y porque no tiene mucho sentido ya que entre ellas las diferencias son excasas***

\

## Análisis de variables temporales

\

**FECHA OCURRENCIA**

\

**FECHA DECLARACIÓN**

\

**FECHA CIERRE**

\

## Análisis de variables cuantitativas

\

**PROVISIÓN INICIAL COBERTURA**

\

**PROVISIÓN COBERTURA**

\

**PAGO TOTAL COBERTURA**

\

**COSTE TOTAL COBERTURA**

\
\

# Análisis multivariante

\
\

# Procesado de variables cualitativas

\
\

# Modelo de regresión lineal

\
\

# Conclusiones preliminares

\
\

# Aprendizaje no supervisado

## K-Means

\
\

# Técnicas de reducción de la dimensionalidad

## PCA

\
\

# Aprendizaje supervisado

## GLM

## KNN

## DECISION TREES

## RANDOM FOREST

## SVM

\
\

# Evaluación y comparación de modelos

## K-fold Cross Validation

## N-fold Cross Validation

\
\

## Conclusiones

\

# Punto de corte ROC

\

# Deep Learning

\
\

# Explicabilidad

\
\

# Series Temporales


