---
title: "LS Insurance"
author: "Sergio Fernández Serrano"
date: "`r format(Sys.Date(), '%d de %B de %Y')`"
output:
  html_document:
    code_folding: hide
    theme: readable
    number_sections: yes
    toc: yes
    toc_depth: 2
    toc_float: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
	echo = TRUE,
	include = TRUE,
	warning = FALSE,
	message = FALSE,
	fig.align = "center",
	out.width = "90%"
)
```

![](LS.jpg)

# Introducción y definición de objetivos

Nos complace presentar un innovador proyecto de machine learning enfocado en la transformación digital del sector asegurador. El objetivo principal es abordar dos desafíos clave en la industria; el análisis exploratorio de los datos de la compañía aseguradora LS y la creación de modelos predictivos para estimar el coste de siniestros y clasificarlos de manera eficiente.

En primer lugar, el análisis exploratorio nos permitirá identificar patrones, tendencias y posibles anomalías en el conjunto de datos proporcionado por la compañía aseguradora. Mediante técnicas avanzadas de visualización y análisis estadístico, seremos capaces de extraer información valiosa y descubrir oportunidades de mejora en la gestión de riesgos y la toma de decisiones.

En segundo lugar, el desarrollo de modelos predictivos basados en machine learning nos permitirá anticiparnos a los costes de siniestros y clasificarlos de manera más precisa. Estos modelos, entrenados con un vasto conjunto de datos históricos, nos brindarán una herramienta eficaz para optimizar la evaluación del riesgo, la asignación de recursos y el diseño de estrategias de prevención.

Con la implementación de este proyecto, aspiramos a impulsar la eficiencia operativa y la rentabilidad de la compañía aseguradora, así como mejorar la calidad del servicio ofrecido a sus clientes. Estamos convencidos de que la adopción de tecnologías de machine learning y el análisis de datos en el sector asegurador es crucial para mantenerse competitivo en un mercado cada vez más exigente y en constante evolución.

**¡Síguenos en este apasionante viaje hacia la digitalización e innovación en el mundo de los seguros!**

\

# Análisis exploratorio inicial

```{r}
paste(R.Version()$version.string)
```

```{r}
library(readr) # Lectura de datos especialmente CSVs
library(readxl) # Lectura de datos especialmente Excel (.xls y .xlsx)
library(dplyr) # Para manipulación y transformación de datos en R
library(tidyr) # Permite manipular la forma de conjuntos de datos en R
library(DT) # Mejora el trabajo con dataframes
library(kableExtra) # Mejora y estiliza tablas
library(ggplot2) # Para gráficos en R
library(GGally) # Extensión de ggplot2, facilitando la visualización de pares y combinaciones de datos
library(gridExtra) # Herramientas para trabajar con múltiples gráficos de ggplot2
library(cowplot) # Para mejoras de gráficos de ggplot2
library(ggcorrplot) # Visualización de matrices de correlación usando ggplot2
library(gmodels) # Varios modelos matemáticos y herramientas estadísticas
library(ggfortify) # Extensión de ggplot2 con funciones para visualizar resultados de varios modelos estadísticos
library(ggridges) # Para hacer Density Ridgeline Plot que son diagramas de densidad por agrupaciones que definamos
library(caret) # Construcción y evaluación de modelos de aprendizaje automático
library(scales) # Herramientas de escalado y formateo de datos
library(class) # Funciones para clasificación
library(distances) # Herramientas para trabajar con distancias y métricas
library(visreg) # Visualización de modelos de regresión
library(rpart) # Paquete de partición recursiva y árboles de regresión
library(rpart.plot) # Visualización de árboles rpart
library(rattle) # Interfaz gráfica y utilidades para minería de datos
library(randomForest) # Paquete que implementa el algoritmo de Random Forest para clasificación y regresión
library(e1071) # Funciones de estadística y aprendizaje automático, incluye máquinas de soporte vectorial
library(pROC) # Herramientas para visualizar y comparar ROC curves
library(cluster) # Métodos de clustering
library(tidyverse) # Colección de paquetes relacionados con la manipulación y visualización de datos (incluye ggplot2, dplyr, tidyr ...)
library(stringr) # Manipulación de cadenas de caracteres
library(Metrics) # Funciones para calcular métricas de modelos predictivos
library(factoextra) # Herramientas de visualización para resultados de descomposición
library(NbClust) # Determina y proporciona el número óptimo de clusters por diferentes métodos

```

## Lectura y preparación de los datos

Leemos el dataset original.

```{r}
LS_original <- read_excel("LS.xlsx")
```

```{r}
LS <- LS_original %>% mutate_at(vars("f_ocurrencia", "f_declaracion", "f_cierre"), as.Date)
```

```{r}
str(LS)
```

```{r}
summary(LS)
```

```{r}
head(LS, 10) %>%
  kbl() %>%
  kable_material(c("striped", "hover")) %>%
  scroll_box(width = "100%", height = "350px")
```

```{r}
dim(LS)
```

\

El dataset contiene **143.930** observaciones (correspondientes a siniestros cada una) y **15** variables (de las cuales son *8* cualitativas, *4* cuantitativas y *3* fechas).

A continuación, la descripción de cada una de las variables:

-   **siniestro**: número identificador del siniestro.

-   **producto**: producto al que va a asociado el siniestro y que tiene una serie de coberturas y garantías en las cuales no entramos.

-   **ramo**: ramo asegurador al que se asigna el siniestro. DJ (defensa jurídica) o PP (pérdida pecuniaria)

-   **tipo**: tipo de seguro en función de la manera en la que se adquiere el riesgo, puede ser adquirido de manera directa a través de la venta directa por la aseguradora (SD - seguro directo) o puede ser un riesgo aceptado si es un riesgo que se adquiere de otra compañía de seguros (RA - reaseguro aceptado).

-   **f_ocurrencia**: fecha en la que ocurre el siniestro.

-   **f_declaracion**: fecha en la que el siniestro es comunicado a la compañía de seguros y es abierto.

-   **f_cierre**: fecha en la que termina el siniestro y es cerrado el expediente.

-   **estado**: estatus en el que se encuentra el siniestro (abierto, cerrado, reaperturado...)

-   **cobertura**: nombre y tipo de cobertura siniestrable que aplica en el siniestro y por la que la compañía proporciona una cobertura al asegurado.

-   **prov_inicial_cob**: provisión con la que se abre el siniestro.

-   **prov_cob**: provisión actual que tiene el siniestro en el momento del análisis a 31/12/2022.

-   **pago_total_cob**: cuantía total que se ha pagado hasta el momento (31/12/2022) en el siniestro.

-   **coste_total_cob**: sumatorio de provision_cobertura_vl + importe_pago_total_cobertura_vl hasta el momento (31/12/2022) en el siniestro.

-   **medio**: vía mediante la cual se ha proporcionado la cobertura. En este caso, como se tratan de defensa jurídica, es la vía jurídica por la que se ha procedido en el siniestro (acuerdo extrajudicial, juicio con abogado de la red interna o juicio con abogado particular)

-   **materia**: asunto principal que motiva el siniestro y que motiva el expediente.

\

## Tratamiento de datos faltantes

No hacemos tratamiento de datos faltantes pues nuestro conocimiento del negocio nos dice que es normal que haya datos faltantes en la variable **f_cierre** ya que puede haber siniestros en estado abierto.

\

## División del dataset

Dividimos el dataset en train, test y validation y posteriormente comprobamos que número de observaciones tiene cada una de las partes respecto al dataset total.

```{r}
set.seed(108)
numero_total = nrow(LS)
# Porcentajes de train, test y validation
w_train = .5
w_test = .25
w_validation = 1 - (w_train + w_test)
# Todos los índices
indices = seq(1:numero_total) 
# Muestreo
indices_train = sample(1:numero_total, numero_total * w_train)
indices_test = sample(indices[-indices_train], numero_total * w_test)
indices_validation = indices[-c(indices_train,indices_test)]
# Agrupamos
LS_train = LS[indices_train,]
LS_test = LS[indices_test,]
LS_validation = LS[indices_validation,]
```

```{r}
nrow(LS)
nrow(LS_train)
nrow(LS_test)
nrow(LS_validation)
```

\
\

# Análisis univariante

## Análisis de variables cualitativas

\

**PRODUCTO**

```{r}
merge(setNames(as.data.frame(table(LS_train$producto)), c("producto", "count")),
      setNames(as.data.frame(round(prop.table(table(LS_train$producto))*100, 2)), c("producto", "prop (%)"))
) %>%
  arrange(desc(count)) %>%
  kbl() %>%
  kable_material(c("striped", "hover")) %>%
  scroll_box(width = "100%", height = "350px")
```

\

**RAMO**

```{r}
merge(setNames(as.data.frame(table(LS_train$ramo)), c("ramo", "count")),
      setNames(as.data.frame(round(prop.table(table(LS_train$ramo))*100, 2)), c("ramo", "prop (%)"))
) %>%
  arrange(desc(count)) %>%
  kbl() %>%
  kable_material(c("striped", "hover")) %>%
  scroll_box(width = "100%", height = "auto")
```

\

**TIPO**

```{r}
merge(setNames(as.data.frame(table(LS_train$tipo)), c("tipo", "count")),
      setNames(as.data.frame(round(prop.table(table(LS_train$tipo))*100, 2)), c("tipo", "prop (%)"))
) %>%
  arrange(desc(count)) %>%
  kbl() %>%
  kable_material(c("striped", "hover")) %>%
  scroll_box(width = "100%", height = "auto")
```

\

**ESTADO**

```{r}
merge(setNames(as.data.frame(table(LS_train$estado)), c("estado", "count")),
      setNames(as.data.frame(round(prop.table(table(LS_train$estado))*100, 2)), c("estado", "prop (%)"))
) %>%
  arrange(desc(count)) %>%
  kbl() %>%
  kable_material(c("striped", "hover")) %>%
  scroll_box(width = "100%", height = "auto")
```

\

**COBERTURA**

```{r}
merge(setNames(as.data.frame(table(LS_train$cobertura)), c("cobertura", "count")),
      setNames(as.data.frame(round(prop.table(table(LS_train$cobertura))*100, 2)), c("cobertura", "prop (%)"))
) %>%
  arrange(desc(count)) %>%
  kbl() %>%
  kable_material(c("striped", "hover")) %>%
  scroll_box(width = "100%", height = "350px")
```

\

**MEDIO**

```{r}
merge(setNames(as.data.frame(table(LS_train$medio)), c("medio", "count")),
      setNames(as.data.frame(round(prop.table(table(LS_train$medio))*100, 2)), c("medio", "prop (%)"))
) %>%
  arrange(desc(count)) %>%
  kbl() %>%
  kable_material(c("striped", "hover")) %>%
  scroll_box(width = "100%", height = "auto")
```

\

**MATERIA**

```{r}
merge(setNames(as.data.frame(table(LS_train$materia)), c("materia", "count")),
      setNames(as.data.frame(round(prop.table(table(LS_train$materia))*100, 2)), c("materia", "prop (%)"))
) %>%
  arrange(desc(count)) %>%
  kbl() %>%
  kable_material(c("striped", "hover")) %>%
  scroll_box(width = "100%", height = "350px")
```

\

```{r}
# PLOT PRODUCTO
# Paso 1: Sumarizar y ordenar los datos
LS_train_primeros15 <- LS_train %>%
  group_by(producto) %>%
  summarize(count = n()) %>%
  arrange(-count) %>%
  slice(1:15) # Paso 2: Limitar a los 15 productos más frecuentes

# Paso 2: Gráfico
plot_producto <- ggplot(LS_train_primeros15, aes(x = reorder(producto, count), y = count)) + 
                    geom_bar(stat = "identity", fill = "#009494") +
                    coord_flip() +
                    labs(x = "producto", y = "Nº producto", title = "Producto") +
                    theme(plot.title = element_text(hjust = 0.5))
                    
                    

# PLOT RAMO                    
plot_ramo <- ggplot(LS_train, aes(ramo)) +
                geom_bar(fill = "#009494") +
                labs(x = "ramo", y = "Nº ramo", title = "Ramo") +
                theme(plot.title = element_text(hjust = 0.5))



# PLOT TIPO
plot_tipo <- ggplot(LS_train, aes(tipo)) +
                geom_bar(fill = "#009494") +
                labs(x = "tipo", y = "Nº tipo", title = "Tipo") +
                theme(plot.title = element_text(hjust = 0.5))



# PLOT ESTADO
# Paso 1: Calcular el número de ocurrencias para cada 'estado'
estado_counts <- LS_train %>% 
  group_by(estado) %>% 
  summarise(n = n()) %>% 
  arrange(-n)

# Paso 2: Usar esa información para reordenar la variable 'estado' en el dataframe
LS_train$estado <- factor(LS_train$estado, levels = estado_counts$estado)

# Paso 3: Crear el gráfico
plot_estado <- ggplot(LS_train, aes(estado)) +
                  geom_bar(fill = "#009494") +
                  labs(x = "estado", y = "Nº estado", title = "Estado") +
                  theme(plot.title = element_text(hjust = 0.5), 
                        axis.text.x = element_text(angle = 15, hjust = 1))
                  


# PLOT MEDIO
# Paso 1: Calcular el número de ocurrencias para cada 'medio'
medio_counts <- LS_train %>% 
  group_by(medio) %>% 
  summarise(n = n()) %>% 
  arrange(-n)

# Paso 2: Usar esa información para reordenar la variable 'medio' en el dataframe
LS_train$medio <- factor(LS_train$medio, levels = medio_counts$medio)

# Paso 3: Crear el gráfico
plot_medio <- ggplot(LS_train, aes(medio)) +
                 geom_bar(fill = "#009494") +
                 labs(x = "medio", y = "Nº medio", title = "Medio") +
                 theme(plot.title = element_text(hjust = 0.5), 
                       axis.text.x = element_text(angle = 15, hjust = 1))
                 
                 

# PLOT MATERIA                 
# Paso 1: Calcular el número de ocurrencias para cada 'materia'
materia_counts <- LS_train %>% 
  group_by(materia) %>% 
  summarise(n = n()) %>% 
  arrange(n)

# Paso 2: Usar esa información para reordenar la variable 'materia' en el dataframe
LS_train$materia <- factor(LS_train$materia, levels = materia_counts$materia)

# Paso 3: Crear el gráfico
plot_materia <- ggplot(LS_train, aes(x = materia)) +
                   geom_bar(fill = "#009494") +
                   coord_flip() + 
                   labs(x = "materia", y = "Nº materia", title = "Materia") +
                   theme(plot.title = element_text(hjust = 0.5))             
```

```{r}
grid.arrange(plot_producto,
             plot_materia,
             ncol=2)
```

\

Para la variable producto sólo representamos los 15 primeros ya que a partir de ahí son muchos los productos pero pocos los siniestros por producto. Se observa como un producto destaca ampliamente sobre el resto, en torno al 47% de los siniestros de esta compañía son del producto CROH.

En cuanto a la materia, destaca ampliamente todo lo que tiene que ver con inmuebles, el 50% de los siniestros.

```{r}
grid.arrange(plot_ramo, 
             plot_tipo,
             ncol=2)
```

Casi el 98% de los siniestros son del ramo de Defensa Jurídica, ramo CORE de LS Insurance y tan sólo el 2% de Pérdidas Pecuniarias.

Algo parecido sudece con el tipo de seguro ya que el 87% son de RA (reaseguro aceptado) y sólo un 13% aproximadamente de SD (seguro Directo). Esto nos indica que la mayor parte de la siniestralidad de la compañía procede de la aceptación de riesgo de otras compañías aseguradoras y no del riesgo que vende LS de manera directa.

```{r}
grid.arrange(plot_estado, 
             plot_medio, 
             ncol=2)
```

El 90% de los siniestros están terminados y a priori no se van a producir cambios en ellos por lo que los datos finales de estos contituyen de manera bastante fiel la realidad de la siniestralidad de la compañía y nos facilitará en gran medida la tarea de clasificar y predecir costes de siniestros.

Por otro lado es relevante apreciar que en al rededor de un 72% de los siniestros terminan siendo gestionados de manera extrajudicial, un 15% en juicios llevados por letrados de la red propia de LS Insurance y un 13% acaban en manos de abogados externos que comunmente provocan un incremento en el coste del siniestro ya que no son llevados por personal interno.

\

\****No se realiza gráfico de la variable cobertura por cuestión estética debido a la gran cantidad de coberturas existentes, casi 200 distintas, y porque no tiene mucho sentido ya que entre ellas las diferencias son excasas***

\

## Análisis de variables temporales

\

```{r}
# Extraer el año y convertirlo en una variable categórica
LS_train <- LS_train %>%
  mutate(year_ocurrencia = as.factor(lubridate::year(f_ocurrencia)),
         year_declaracion = as.factor(lubridate::year(f_declaracion)),
         year_cierre = as.factor(lubridate::year(f_cierre)))
```


**FECHA OCURRENCIA**

```{r}
tabla_ocurrencia <- LS_train %>%
  group_by(year_ocurrencia) %>%
  summarise(count = n()) %>%
  mutate(prop = round((count / sum(count)) * 100, 2)) %>%
  arrange(desc(count))

tabla_ocurrencia %>%
  kbl(col.names = c("year", "count", "prop (%)")) %>%
  kable_material(c("striped", "hover")) %>%
  scroll_box(width = "100%", height = "350px")
```

```{r}
# PLOT AÑO OCURRENCIA
plot_year_ocurrencia <- ggplot(LS_train, aes(x = year_ocurrencia)) +
  geom_line(stat = 'count', aes(group = 1), color = "#009494") +
  labs(x = "Año de ocurrencia", y = "Nº de siniestros", title = "Siniestros por año de ocurrencia") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5))
```


\

**FECHA DECLARACIÓN**

```{r}
tabla_declaracion <- LS_train %>%
  group_by(year_declaracion) %>%
  summarise(count = n()) %>%
  mutate(prop = round((count / sum(count)) * 100, 2)) %>%
  arrange(desc(count))

tabla_declaracion %>%
  kbl(col.names = c("year", "count", "prop (%)")) %>%
  kable_material(c("striped", "hover")) %>%
  scroll_box(width = "100%", height = "350px")
```

```{r}
# PLOT AÑO DECLARACIÓN
plot_year_declaracion <- ggplot(LS_train, aes(x = year_declaracion)) +
  geom_line(stat = 'count', aes(group = 1), color = "#009494") +
  labs(x = "Año de declaración", y = "Nº de siniestros", title = "Siniestros por año de declaración") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5))
```

\

**FECHA CIERRE**

```{r}
tabla_cierre <- LS_train %>%
  group_by(year_cierre) %>%
  summarise(count = n()) %>%
  mutate(prop = round((count / sum(count)) * 100, 2)) %>%
  arrange(desc(count))

tabla_cierre %>%
  kbl(col.names = c("year", "count", "prop (%)")) %>%
  kable_material(c("striped", "hover")) %>%
  scroll_box(width = "100%", height = "350px")
```

```{r}
# PLOT AÑO CIERRE
plot_year_cierre <- ggplot(LS_train, aes(x = year_cierre)) +
  geom_line(stat = 'count', aes(group = 1), color = "#009494") +
  labs(x = "Año de cierre", y = "Nº de siniestros", title = "Siniestros por año de cierre") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5))
```

\

```{r}
# GRÁFICOS JUNTOS POR AÑO
# Primero hay que modificar el dataframe para que las fechas estén en una sola columna y tener otra columna que identifique el tipo de fecha
LS_train_long <- LS_train %>%
  select(siniestro, year_ocurrencia, year_declaracion, year_cierre) %>%
  gather(key = "Tipo de Fecha", value = "Año", -siniestro)

plot_fechas_año <- ggplot(LS_train_long, aes(x = Año, group = `Tipo de Fecha`)) +
  geom_line(stat = 'count', aes(color = `Tipo de Fecha`)) +
  labs(x = "Año", y = "Nº de siniestros", title = "Siniestros por año según tipo de fecha") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5)) +
  scale_color_manual(values = c("year_ocurrencia" = "blue", "year_declaracion" = "green", "year_cierre" = "red"),
                     name = "Tipo de Fecha")

print(plot_fechas_año)
```

Podemos observar la tendencia de que año tras año el número de siniestros que ocurren y son declaran por parte de los asegurados es creciente y con una pendiente bastante acentuada. 

Esto puede ser por varios motivos pero uno de los principales en este negocio es el crecimiento de la cartera y la asunción de nuevos riesgo con el correspondiente crecimiento de las primas devengadas anuales. Este hecho no lo podemos comprobar ya que el dataset carece de datos relativos a primas, no obstante, nuestro conocimiento del negocio nos hace pensar que es así.

Importante a tener en cuenta es que los crecimientos de cartera y en número de siniestros no siempre son proporcionales, no todas las carteras (productos) tienen los mismo comportamientos y en el estudio de la rentabilidad de las mismas hay que tener en cuenta la rentabilidad o el ratio de siniestralidad de las mismas.

```{r}
# PLOT MES OCURRENCIA
LS_train$mes_ocurrencia <- lubridate::month(LS_train$f_ocurrencia, label = TRUE)

plot_mes_ocurrencia <- ggplot(LS_train, aes(mes_ocurrencia)) + 
  geom_bar(fill = "#009494") +
  labs(x = "Mes de ocurrencia", y = "Nº de siniestros", title = "Distribución de siniestros ocurridos por mes") +
  theme(plot.title = element_text(hjust = 0.5))



# PLOT MES DECLARACIÓN
LS_train$mes_declaracion <- lubridate::month(LS_train$f_declaracion, label = TRUE)

plot_mes_declaracion <- ggplot(LS_train, aes(mes_declaracion)) + 
  geom_bar(fill = "#009494") +
  labs(x = "Mes de declaración", y = "Nº de siniestros", title = "Distribución de siniestros declarados por mes") +
  theme(plot.title = element_text(hjust = 0.5))



# PLOT MES CIERRE
LS_train$mes_cierre <- lubridate::month(LS_train$f_cierre, label = TRUE)

plot_mes_cierre <- ggplot(LS_train, aes(mes_cierre)) + 
  geom_bar(fill = "#009494") +
  labs(x = "Mes de cierre", y = "Nº de siniestros", title = "Distribución de siniestros cerrados por mes") +
  theme(plot.title = element_text(hjust = 0.5))
```

```{r}
plot_mes_ocurrencia
plot_mes_declaracion
plot_mes_cierre
```

Respecto al número de siniestros ocurridos por mes hay una distribución más o menos homogénea pero se aprecia que hay menor número de siniestros en los meses donde hay mayores festividades, abril y diciembre, así como agosto por el periodo vacacional de verano. 

Esto se acentúa en los momentos de declarar siniestros por parte de los asegurados que normalmente esperan unos días en comunicarlos en caso de encontrarse en periodos estivales. Y pasa lo mismo en lo que respecta al cierre de siniestros por parte de los tramitadores de LS Insurance.

Intuímos un cierto patrón; los meses sin fiestas sube el número de siniestros ocurridos, declarados y cerrados mientras que por el contrario los meses con fiestas este número de siniestros baja.

```{r}
LS_train$dias_para_declarar <- as.numeric(difftime(LS_train$f_declaracion, LS_train$f_ocurrencia, units = "days"))
LS_train$dias_para_cerrar <- as.numeric(difftime(LS_train$f_cierre, LS_train$f_declaracion, units = "days"))

# Histograma con línea de densidad para días para declarar
plot_dias_para_declarar <- ggplot(LS_train, aes(x = dias_para_declarar)) +
  geom_histogram(aes(y = ..density..), fill = "#009494", bins = 50, alpha = 0.7) +
  geom_density(color = "green", size = 1.2) +
  labs(x = "Días para declarar", y = "Densidad", title = "Distribución de días para declarar") +
  theme(plot.title = element_text(hjust = 0.5))

# Histograma con línea de densidad para días para cerrar
plot_dias_para_cerrar <- ggplot(LS_train, aes(x = dias_para_cerrar)) +
  geom_histogram(aes(y = ..density..), fill = "#009494", bins = 50, alpha = 0.7) +
  geom_density(color = "red", size = 1.2) +
  labs(x = "Días para cerrar", y = "Densidad", title = "Distribución de días para cerrar") +
  theme(plot.title = element_text(hjust = 0.5))

# Para visualizar los gráficos, simplemente ejecuta sus nombres:
grid.arrange(plot_dias_para_declarar, 
             plot_dias_para_cerrar, 
             ncol=2)
```

```{r}
# Porcentaje de siniestros declarados antes de 90 días
porcentaje_declara_antes_90 <- mean(LS_train$dias_para_declarar < 90) * 100
porcentaje_declara_antes_365 <- mean(LS_train$dias_para_declarar < 365) * 100

# Porcentaje de siniestros cerrados antes de 90 días (excluyendo los NA)
porcentaje_cierra_antes_90 <- mean(LS_train$dias_para_cerrar < 90, na.rm = TRUE) * 100
porcentaje_cierra_antes_365 <- mean(LS_train$dias_para_cerrar < 365, na.rm = TRUE) * 100

cat(paste0("% de siniestros declarados antes de 90 días: ", round(porcentaje_declara_antes_90, 2), "%\n"))
cat(paste0("% de siniestros declarados antes de 365 días: ", round(porcentaje_declara_antes_365, 2), "%\n"))
cat(paste0("% de siniestros cerrados antes de 90 días: ", round(porcentaje_cierra_antes_90, 2), "%\n"))
cat(paste0("% de siniestros cerrados antes de 365 días: ", round(porcentaje_cierra_antes_365, 2), "%\n"))
```

Aunque el 77% de los siniestros se declara en los primeros 3 meses, exite un alto porcentaje de que el asegurado se demore en la comunicación de los mismos llegando a veces a tardar más de 1 año, lo cual es bastante malo para el negocio ya que afecta negativamente incrementando las reservas de la compañía en lo que se conoce como provisión de siniestros pendinetes de declaración (PSPD/IBNR), es decir reservar un dinero para siniestro que no están comunicados pero que la compañía tiene que preveer que se comunicarán y estimar el coste de los mismos.

Con el segundo gráfico pretendía demostrar que este tipo de siniestros son de cola larga superando en un alto porcentaje el año en las gestiones de tramitación. Esto se debe principalmente al ramo que comercializa LS Insurance ya que al tratarse de defensa y asesoramiento jurídico se demora bastante los pacto extrajudiciales por no hablar de los que acaban en tela de juicio que todavía se demoran más.

```{r}
# PLOT HEATMAP MES OCURRENCIA
ocurrencia_counts <- LS_train %>%
  group_by(year = year(f_ocurrencia), month = month(f_ocurrencia, label = TRUE)) %>%
  summarise(count = n())

plot_heatmap_ocurrencia <- ggplot(ocurrencia_counts, aes(y = month, x = factor(year), fill = count)) + 
                              geom_tile() + 
                              labs(title = "Siniestros por Fecha de Ocurrencia", y = "Mes", x = "Año") +
                              scale_fill_gradient(low = "white", high = "red") +
                              theme(plot.title = element_text(hjust = 0.5),
                                    axis.text.x = element_text(angle = 35, hjust = 1))



# PLOT HEATMAP MES DECLARACIÓN
declaración_counts <- LS_train %>%
  group_by(year = year(f_declaracion), month = month(f_declaracion, label = TRUE)) %>%
  summarise(count = n())

plot_heatmap_declaración <- ggplot(declaración_counts, aes(y = month, x = factor(year), fill = count)) + 
                              geom_tile() + 
                              labs(title = "Siniestros por Fecha de Declaración", y = "Mes", x = "Año") +
                              scale_fill_gradient(low = "white", high = "red") +
                              theme(plot.title = element_text(hjust = 0.5),
                                    axis.text.x = element_text(angle = 35, hjust = 1))



# PLOT HEATMAP MES CIERRE
cierre_counts <- LS_train %>%
  group_by(year = year(f_cierre), month = month(f_cierre, label = TRUE)) %>%
  summarise(count = n())

plot_heatmap_cierre <- ggplot(cierre_counts, aes(y = month, x = factor(year), fill = count)) + 
                              geom_tile() + 
                              labs(title = "Siniestros por Fecha de Cierre", y = "Mes", x = "Año") +
                              scale_fill_gradient(low = "white", high = "red") +
                              theme(plot.title = element_text(hjust = 0.5),
                                    axis.text.x = element_text(angle = 35, hjust = 1))
```

```{r}
grid.arrange(plot_heatmap_ocurrencia,
             plot_heatmap_declaración,
             ncol=2)
```

Los heatmaps anteriores continúan demostrando como conforme han ido pasando los años hay un creciente número de siniestros ocurridos y comunicados así como la confirmación del patrón que mencionábamos con anterioridad sobre las diferencias entre meses con festividades y meses sin ellas.

\

\****No se realiza gráfico heatmap de la variable f_cierre porque su visualización no aporta gran información sobre los años y meses que más siniestros se cierran ya que hay un alto porcentaje de siniestros que continúan abiertos.***

\

## Análisis de variables cuantitativas

\

**PROVISIÓN INICIAL COBERTURA**

```{r}
# Estadísticas descriptivas para prov_inicial_cob
stats_prov_inicial <- LS_train %>%
  summarize(
    Minimo = round(min(prov_inicial_cob, na.rm = TRUE), 2),
    Maximo = round(max(prov_inicial_cob, na.rm = TRUE), 2),
    Mediana = round(median(prov_inicial_cob, na.rm = TRUE), 2),
    Media = round(mean(prov_inicial_cob, na.rm = TRUE), 2),
    Desviacion_Estandar = round(sd(prov_inicial_cob, na.rm = TRUE), 2),
    Varianza = round(var(prov_inicial_cob, na.rm = TRUE), 2),
    Q1 = round(quantile(prov_inicial_cob, 0.25, na.rm = TRUE), 2),
    Q3 = round(quantile(prov_inicial_cob, 0.75, na.rm = TRUE), 2)
  ) %>%
  mutate(
    Rango = round(Maximo - Minimo, 2),
    Rango_Intercuartilico = round(Q3 - Q1, 2)
  ) %>%
  gather("Estadístico", "Valor")

# Estadísticas descriptivas para prov_inicial_cob excluyendo 0.00
stats_prov_inicial_sin_ceros <- LS_train %>%
  filter(prov_inicial_cob != 0.00) %>%
  summarize(
    Minimo = round(min(prov_inicial_cob, na.rm = TRUE), 2),
    Maximo = round(max(prov_inicial_cob, na.rm = TRUE), 2),
    Mediana = round(median(prov_inicial_cob, na.rm = TRUE), 2),
    Media = round(mean(prov_inicial_cob, na.rm = TRUE), 2),
    Desviacion_Estandar = round(sd(prov_inicial_cob, na.rm = TRUE), 2),
    Varianza = round(var(prov_inicial_cob, na.rm = TRUE), 2),
    Q1 = round(quantile(prov_inicial_cob, 0.25, na.rm = TRUE), 2),
    Q3 = round(quantile(prov_inicial_cob, 0.75, na.rm = TRUE), 2)
  ) %>%
  mutate(
    Rango = round(Maximo - Minimo, 2),
    Rango_Intercuartilico = round(Q3 - Q1, 2)
  ) %>%
  gather("Estadístico", "Valor_sin_ceros")

# Agregamos la moda como una fila adicional con 0.00 y sin 0.00
mode_value <- as.numeric(names(sort(table(LS_train$prov_inicial_cob), decreasing = TRUE)[1]))
stats_prov_inicial <- rbind(stats_prov_inicial, data.frame(Estadístico = "Moda", Valor = round(mode_value, 2)))

mode_value_sin_ceros <- as.numeric(names(sort(table(filter(LS_train, prov_inicial_cob != 0.00)$prov_inicial_cob), decreasing = TRUE)[1]))
stats_prov_inicial_sin_ceros <- rbind(stats_prov_inicial_sin_ceros, data.frame(Estadístico = "Moda", Valor_sin_ceros = round(mode_value_sin_ceros, 2)))

# Fusionamos las dos tablas
stats_prov_inicial <- left_join(stats_prov_inicial, stats_prov_inicial_sin_ceros, by = "Estadístico")

# Convertir la tabla a kbl
tabla_prov_inicial <- kbl(stats_prov_inicial, align = c("c", "c", "c"), col.names = c("Estadístico", "Valor", "Valor sin 0.00")) %>%
  kable_material()

tabla_prov_inicial
```

```{r}
# PLOT HISTOGRAMA PROVISIÓN INICIAL COBERTURA
plot_hist_dens_prov_inicial <- ggplot(LS_train, aes(x=prov_inicial_cob)) +
                                  geom_histogram(aes(y=..density..), fill="#009494", bins=20) +
                                  geom_density(alpha=0.2, color="#D55E00") + 
                                  labs(title="Hist. y Dens. prov_inicial_cob", y="Densidad") +
                                  theme(plot.title = element_text(hjust = 0.5))



# PLOT BOXPLOT PROVISIÓN INICIAL COBERTURA
plot_boxplot_prov_inicial <- ggplot(LS_train, aes(y=prov_inicial_cob)) +
                                geom_boxplot(fill="#009494", outlier.color="#D55E00", outlier.shape=16, outlier.size=2) +
                                labs(title="Boxplot prov_inicial_cob") +
                                theme(plot.title = element_text(hjust = 0.5))



# PLOT SCATTERPLOT PROVISIÓN INICIAL COBERTURA
plot_geomplot_prov_inicial <- ggplot(LS_train, aes(x=seq_along(prov_inicial_cob), y=prov_inicial_cob)) +
                                 geom_point(color="#009494", alpha=0.4) +
                                 labs(title="Scatter Plot prov_inicial_cob", x="Índice", y="Valor") +
                                 theme(plot.title = element_text(hjust = 0.5))



# PLOT QQPLOT PROVISIÓN INICIAL COBERTURA
plot_qqplot_prov_inicial <- ggplot(LS_train, aes(sample=prov_inicial_cob)) +
                               stat_qq(distribution=stats::qnorm, dparams=list(mean=mean(LS_train$prov_inicial_cob, na.rm=TRUE), sd=sd(LS_train$prov_inicial_cob, na.rm=TRUE))) +
                               geom_abline(intercept=0, slope=1, color="#D55E00") +
                               labs(title="Q-Q Plot prov_inicial_cob") +
                               theme(plot.title = element_text(hjust = 0.5))



# Filtrar el dataset para excluir los valores de 0.00
LS_train_filtered_0.00 <- LS_train %>% filter(prov_inicial_cob != 0.00)

# PLOT HISTOGRAMA PROVISIÓN INICIAL COBERTURA SIN 0.00
plot_hist_dens_prov_inicial_filtered_0.00 <- ggplot(LS_train_filtered_0.00, aes(x=prov_inicial_cob)) +
                                                geom_histogram(aes(y=..density..), fill="#009494", bins=20) +
                                                geom_density(alpha=0.2, color="#D55E00") + 
                                                labs(title="Hist. y Dens. prov_inicial_cob <> 0.00", y="Densidad") +
                                                theme(plot.title = element_text(hjust = 0.5))



# PLOT BOXPLOT PROVISIÓN INICIAL COBERTURA SIN 0.00
plot_boxplot_prov_inicial_filtered_0.00 <- ggplot(LS_train_filtered_0.00, aes(y=prov_inicial_cob)) +
                                              geom_boxplot(fill="#009494", outlier.color="#D55E00", outlier.shape=16, outlier.size=2) +
                                              labs(title="Boxplot prov_inicial_cob <> 0.00") +
                                              theme(plot.title = element_text(hjust = 0.5))



# PLOT SCATTERPLOT PROVISIÓN INICIAL COBERTURA SIN 0.00
plot_geomplot_prov_inicial_filtered_0.00 <- ggplot(LS_train_filtered_0.00, aes(x=seq_along(prov_inicial_cob), y=prov_inicial_cob)) +
                                               geom_point(color="#009494", alpha=0.4) +
                                               labs(title="Scatter Plot prov_inicial_cob <> 0.00", x="Índice", y="Valor") +
                                               theme(plot.title = element_text(hjust = 0.5))



# PLOT QQPLOT PROVISIÓN INICIAL COBERTURA SIN 0.00
plot_qqplot_prov_inicial_filtered_0.00 <- ggplot(LS_train_filtered_0.00, aes(sample=prov_inicial_cob)) +
                                             stat_qq(distribution=stats::qnorm, dparams=list(mean=mean(LS_train_filtered_0.00$prov_inicial_cob, na.rm=TRUE), sd=sd(LS_train_filtered_0.00$prov_inicial_cob, na.rm=TRUE))) +
                                             geom_abline(intercept=0, slope=1, color="#D55E00") +
                                             labs(title="Q-Q Plot prov_inicial_cob <> 0.00") +
                                             theme(plot.title = element_text(hjust = 0.5))
```

```{r}
grid.arrange(plot_hist_dens_prov_inicial,
             plot_hist_dens_prov_inicial_filtered_0.00,
             ncol=2)



grid.arrange(plot_boxplot_prov_inicial,
             plot_boxplot_prov_inicial_filtered_0.00,
             ncol=2)



grid.arrange(plot_geomplot_prov_inicial,
             plot_geomplot_prov_inicial_filtered_0.00,
             ncol=2)



grid.arrange(plot_qqplot_prov_inicial,
             plot_qqplot_prov_inicial_filtered_0.00,
             ncol=2)
```

\

**PROVISIÓN COBERTURA**

```{r}
# Estadísticas descriptivas para prov_cob
stats_prov_cob <- LS_train %>%
  summarize(
    Minimo = round(min(prov_cob, na.rm = TRUE), 2),
    Maximo = round(max(prov_cob, na.rm = TRUE), 2),
    Mediana = round(median(prov_cob, na.rm = TRUE), 2),
    Media = round(mean(prov_cob, na.rm = TRUE), 2),
    Desviacion_Estandar = round(sd(prov_cob, na.rm = TRUE), 2),
    Varianza = round(var(prov_cob, na.rm = TRUE), 2),
    Q1 = round(quantile(prov_cob, 0.25, na.rm = TRUE), 2),
    Q3 = round(quantile(prov_cob, 0.75, na.rm = TRUE), 2)
  ) %>%
  mutate(
    Rango = round(Maximo - Minimo, 2),
    Rango_Intercuartilico = round(Q3 - Q1, 2)
  ) %>%
  gather("Estadístico", "Valor")

# Estadísticas descriptivas para prov_cob excluyendo 0.00
stats_prov_cob_sin_ceros <- LS_train %>%
  filter(prov_cob != 0.00) %>%
  summarize(
    Minimo = round(min(prov_cob, na.rm = TRUE), 2),
    Maximo = round(max(prov_cob, na.rm = TRUE), 2),
    Mediana = round(median(prov_cob, na.rm = TRUE), 2),
    Media = round(mean(prov_cob, na.rm = TRUE), 2),
    Desviacion_Estandar = round(sd(prov_cob, na.rm = TRUE), 2),
    Varianza = round(var(prov_cob, na.rm = TRUE), 2),
    Q1 = round(quantile(prov_cob, 0.25, na.rm = TRUE), 2),
    Q3 = round(quantile(prov_cob, 0.75, na.rm = TRUE), 2)
  ) %>%
  mutate(
    Rango = round(Maximo - Minimo, 2),
    Rango_Intercuartilico = round(Q3 - Q1, 2)
  ) %>%
  gather("Estadístico", "Valor_sin_ceros")

# Agregamos la moda como una fila adicional con 0.00 y sin 0.00
mode_value_prov_cob <- as.numeric(names(sort(table(LS_train$prov_cob), decreasing = TRUE)[1]))
stats_prov_cob <- rbind(stats_prov_cob, data.frame(Estadístico = "Moda", Valor = round(mode_value_prov_cob, 2)))

mode_value_prov_cob_sin_ceros <- as.numeric(names(sort(table(filter(LS_train, prov_cob != 0.00)$prov_cob), decreasing = TRUE)[1]))
stats_prov_cob_sin_ceros <- rbind(stats_prov_cob_sin_ceros, data.frame(Estadístico = "Moda", Valor_sin_ceros = round(mode_value_prov_cob_sin_ceros, 2)))

# Fusionamos las dos tablas
stats_prov_cob <- left_join(stats_prov_cob, stats_prov_cob_sin_ceros, by = "Estadístico")

# Convertir la tabla a kbl
tabla_prov_cob <- kbl(stats_prov_cob, align = c("c", "c", "c"), col.names = c("Estadístico", "Valor", "Valor sin 0.00")) %>%
  kable_material()

tabla_prov_cob
```

```{r}
# PLOT HISTOGRAMA PROVISIÓN COBERTURA
plot_hist_dens_prov_cob <- ggplot(LS_train, aes(x=prov_cob)) +
                              geom_histogram(aes(y=..density..), fill="#009494", bins=20) +
                              geom_density(alpha=0.2, color="#D55E00") + 
                              labs(title="Hist. y Dens. prov_cob", y="Densidad") +
                              theme(plot.title = element_text(hjust = 0.5))



# PLOT BOXPLOT PROVISIÓN COBERTURA
plot_boxplot_prov_cob <- ggplot(LS_train, aes(y=prov_cob)) +
                            geom_boxplot(fill="#009494", outlier.color="#D55E00", outlier.shape=16, outlier.size=2) +
                            labs(title="Boxplot prov_cob") +
                            theme(plot.title = element_text(hjust = 0.5))



# PLOT SCATTERPLOT PROVISIÓN COBERTURA
plot_geomplot_prov_cob <- ggplot(LS_train, aes(x=seq_along(prov_cob), y=prov_cob)) +
                             geom_point(color="#009494", alpha=0.4) +
                             labs(title="Scatter Plot prov_cob", x="Índice", y="Valor") +
                             theme(plot.title = element_text(hjust = 0.5))



# PLOT QQPLOT PROVISIÓN COBERTURA
plot_qqplot_prov_cob <- ggplot(LS_train, aes(sample=prov_cob)) +
                           stat_qq(distribution=stats::qnorm, dparams=list(mean=mean(LS_train$prov_cob, na.rm=TRUE), sd=sd(LS_train$prov_cob, na.rm=TRUE))) +
                           geom_abline(intercept=0, slope=1, color="#D55E00") +
                           labs(title="Q-Q Plot prov_cob") +
                           theme(plot.title = element_text(hjust = 0.5))



# Filtrar el dataset para excluir los valores de 0.00 en prov_cob
LS_train_filtered_prov_cob_0.00 <- LS_train %>% filter(prov_cob != 0.00)

# PLOT HISTOGRAMA PROVISIÓN COBERTURA SIN 0.00
plot_hist_dens_prov_cob_filtered_0.00 <- ggplot(LS_train_filtered_prov_cob_0.00, aes(x=prov_cob)) +
                                            geom_histogram(aes(y=..density..), fill="#009494", bins=20) +
                                            geom_density(alpha=0.2, color="#D55E00") + 
                                            labs(title="Hist. y Dens. prov_cob <> 0.00", y="Densidad") +
                                            theme(plot.title = element_text(hjust = 0.5))



# PLOT BOXPLOT PROVISIÓN COBERTURA SIN 0.00
plot_boxplot_prov_cob_filtered_0.00 <- ggplot(LS_train_filtered_prov_cob_0.00, aes(y=prov_cob)) +
                                          geom_boxplot(fill="#009494", outlier.color="#D55E00", outlier.shape=16, outlier.size=2) +
                                          labs(title="Boxplot prov_cob <> 0.00") +
                                          theme(plot.title = element_text(hjust = 0.5))



# PLOT SCATTERPLOT PROVISIÓN COBERTURA SIN 0.00
plot_geomplot_prov_cob_filtered_0.00 <- ggplot(LS_train_filtered_prov_cob_0.00, aes(x=seq_along(prov_cob), y=prov_cob)) +
                                           geom_point(color="#009494", alpha=0.4) +
                                           labs(title="Scatter Plot prov_cob <> 0.00", x="Índice", y="Valor") +
                                           theme(plot.title = element_text(hjust = 0.5))



# PLOT QQPLOT PROVISIÓN COBERTURA SIN 0.00
plot_qqplot_prov_cob_filtered_0.00 <- ggplot(LS_train_filtered_prov_cob_0.00, aes(sample=prov_cob)) +
                                         stat_qq(distribution=stats::qnorm, dparams=list(mean=mean(LS_train_filtered_prov_cob_0.00$prov_cob, na.rm=TRUE), sd=sd(LS_train_filtered_prov_cob_0.00$prov_cob, na.rm=TRUE))) +
                                         geom_abline(intercept=0, slope=1, color="#D55E00") +
                                         labs(title="Q-Q Plot prov_cob <> 0.00") +
                                         theme(plot.title = element_text(hjust = 0.5))
```

```{r}
grid.arrange(plot_hist_dens_prov_cob,
             plot_hist_dens_prov_cob_filtered_0.00,
             ncol=2)



grid.arrange(plot_boxplot_prov_cob,
             plot_boxplot_prov_cob_filtered_0.00,
             ncol=2)



grid.arrange(plot_geomplot_prov_cob,
             plot_geomplot_prov_cob_filtered_0.00,
             ncol=2)



grid.arrange(plot_qqplot_prov_cob,
             plot_qqplot_prov_cob_filtered_0.00,
             ncol=2)
```

\

**PAGO TOTAL COBERTURA**

```{r}
# Estadísticas descriptivas para pago_total_cob
stats_pago_total_cob <- LS_train %>%
  summarize(
    Minimo = round(min(pago_total_cob, na.rm = TRUE), 2),
    Maximo = round(max(pago_total_cob, na.rm = TRUE), 2),
    Mediana = round(median(pago_total_cob, na.rm = TRUE), 2),
    Media = round(mean(pago_total_cob, na.rm = TRUE), 2),
    Desviacion_Estandar = round(sd(pago_total_cob, na.rm = TRUE), 2),
    Varianza = round(var(pago_total_cob, na.rm = TRUE), 2),
    Q1 = round(quantile(pago_total_cob, 0.25, na.rm = TRUE), 2),
    Q3 = round(quantile(pago_total_cob, 0.75, na.rm = TRUE), 2)
  ) %>%
  mutate(
    Rango = round(Maximo - Minimo, 2),
    Rango_Intercuartilico = round(Q3 - Q1, 2)
  ) %>%
  gather("Estadístico", "Valor")

# Estadísticas descriptivas para pago_total_cob excluyendo 0.00
stats_pago_total_cob_sin_ceros <- LS_train %>%
  filter(pago_total_cob != 0.00) %>%
  summarize(
    Minimo = round(min(pago_total_cob, na.rm = TRUE), 2),
    Maximo = round(max(pago_total_cob, na.rm = TRUE), 2),
    Mediana = round(median(pago_total_cob, na.rm = TRUE), 2),
    Media = round(mean(pago_total_cob, na.rm = TRUE), 2),
    Desviacion_Estandar = round(sd(pago_total_cob, na.rm = TRUE), 2),
    Varianza = round(var(pago_total_cob, na.rm = TRUE), 2),
    Q1 = round(quantile(pago_total_cob, 0.25, na.rm = TRUE), 2),
    Q3 = round(quantile(pago_total_cob, 0.75, na.rm = TRUE), 2)
  ) %>%
  mutate(
    Rango = round(Maximo - Minimo, 2),
    Rango_Intercuartilico = round(Q3 - Q1, 2)
  ) %>%
  gather("Estadístico", "Valor_sin_ceros")

# Agregamos la moda como una fila adicional con 0.00 y sin 0.00
mode_value_pago_total_cob <- as.numeric(names(sort(table(LS_train$pago_total_cob), decreasing = TRUE)[1]))
stats_pago_total_cob <- rbind(stats_pago_total_cob, data.frame(Estadístico = "Moda", Valor = round(mode_value_pago_total_cob, 2)))

mode_value_pago_total_cob_sin_ceros <- as.numeric(names(sort(table(filter(LS_train, pago_total_cob != 0.00)$pago_total_cob), decreasing = TRUE)[1]))
stats_pago_total_cob_sin_ceros <- rbind(stats_pago_total_cob_sin_ceros, data.frame(Estadístico = "Moda", Valor_sin_ceros = round(mode_value_pago_total_cob_sin_ceros, 2)))

# Fusionamos las dos tablas
stats_pago_total_cob <- left_join(stats_pago_total_cob, stats_pago_total_cob_sin_ceros, by = "Estadístico")

# Convertir la tabla a kbl
tabla_pago_total_cob <- kbl(stats_pago_total_cob, align = c("c", "c", "c"), col.names = c("Estadístico", "Valor", "Valor sin 0.00")) %>%
  kable_material()

tabla_pago_total_cob
```

```{r}
# PLOT HISTOGRAMA PAGO TOTAL COBERTURA
plot_hist_dens_pago_total_cob <- ggplot(LS_train, aes(x=pago_total_cob)) +
		                    geom_histogram(aes(y=..density..), fill="#009494", bins=20) +
		                    geom_density(alpha=0.2, color="#D55E00") + 
		                    labs(title="Hist. y Dens. pago_total_cob", y="Densidad") +
		                    theme(plot.title = element_text(hjust = 0.5))



# PLOT BOXPLOT PAGO TOTAL COBERTURA
plot_boxplot_pago_total_cob <- ggplot(LS_train, aes(y=pago_total_cob)) +
		                  geom_boxplot(fill="#009494", outlier.color="#D55E00", outlier.shape=16, outlier.size=2) +
		                  labs(title="Boxplot pago_total_cob") +
		                  theme(plot.title = element_text(hjust = 0.5))



# PLOT SCATTERPLOT PAGO TOTAL COBERTURA
plot_geomplot_pago_total_cob <- ggplot(LS_train, aes(x=seq_along(pago_total_cob), y=pago_total_cob)) +
		                   geom_point(color="#009494", alpha=0.4) +
		                   labs(title="Scatter Plot pago_total_cob", x="Índice", y="Valor") +
		                   theme(plot.title = element_text(hjust = 0.5))



# PLOT QQPLOT PAGO TOTAL COBERTURA
plot_qqplot_pago_total_cob <- ggplot(LS_train, aes(sample=pago_total_cob)) +
		                 stat_qq(distribution=stats::qnorm, dparams=list(mean=mean(LS_train$pago_total_cob, na.rm=TRUE), sd=sd(LS_train$pago_total_cob, na.rm=TRUE))) +
		                 geom_abline(intercept=0, slope=1, color="#D55E00") +
		                 labs(title="Q-Q Plot pago_total_cob") +
		                 theme(plot.title = element_text(hjust = 0.5))



# Filtrar el dataset para excluir los valores de 0.00 en pago_total_cob
LS_train_filtered_pago_total_cob_0.00 <- LS_train %>% filter(pago_total_cob != 0.00)

# PLOT HISTOGRAMA PAGO TOTAL COBERTURA SIN 0.00
plot_hist_dens_pago_total_cob_filtered_0.00 <- ggplot(LS_train_filtered_pago_total_cob_0.00, aes(x=pago_total_cob)) +
                                                  geom_histogram(aes(y=..density..), fill="#009494", bins=20) +
                                                  geom_density(alpha=0.2, color="#D55E00") + 
                                                  labs(title="Hist. y Dens. pago_total_cob <> 0.00", y="Densidad") +
                                                  theme(plot.title = element_text(hjust = 0.5))



# PLOT BOXPLOT PAGO TOTAL COBERTURA SIN 0.00
plot_boxplot_pago_total_cob_filtered_0.00 <- ggplot(LS_train_filtered_pago_total_cob_0.00, aes(y=pago_total_cob)) +
                                                geom_boxplot(fill="#009494", outlier.color="#D55E00", outlier.shape=16, outlier.size=2) +
                                                labs(title="Boxplot pago_total_cob <> 0.00") +
                                                theme(plot.title = element_text(hjust = 0.5))



# PLOT SCATTERPLOT PAGO TOTAL COBERTURA SIN 0.00
plot_geomplot_pago_total_cob_filtered_0.00 <- ggplot(LS_train_filtered_pago_total_cob_0.00, aes(x=seq_along(pago_total_cob), y=pago_total_cob)) +
                                                 geom_point(color="#009494", alpha=0.4) +
                                                 labs(title="Scatter Plot pago_total_cob <> 0.00", x="Índice", y="Valor") +
                                                 theme(plot.title = element_text(hjust = 0.5))



# PLOT QQPLOT PAGO TOTAL COBERTURA SIN 0.00
plot_qqplot_pago_total_cob_filtered_0.00 <- ggplot(LS_train_filtered_pago_total_cob_0.00, aes(sample=pago_total_cob)) +
                                               stat_qq(distribution=stats::qnorm, dparams=list(mean=mean(LS_train_filtered_pago_total_cob_0.00$pago_total_cob, na.rm=TRUE), sd=sd(LS_train_filtered_pago_total_cob_0.00$pago_total_cob, na.rm=TRUE))) +
                                               geom_abline(intercept=0, slope=1, color="#D55E00") +
                                               labs(title="Q-Q Plot pago_total_cob <> 0.00") +
                                               theme(plot.title = element_text(hjust = 0.5))
```

```{r}
grid.arrange(plot_hist_dens_pago_total_cob,
             plot_hist_dens_pago_total_cob_filtered_0.00,
             ncol=2)



grid.arrange(plot_boxplot_pago_total_cob,
             plot_boxplot_pago_total_cob_filtered_0.00,
             ncol=2)



grid.arrange(plot_geomplot_pago_total_cob,
             plot_geomplot_pago_total_cob_filtered_0.00,
             ncol=2)



grid.arrange(plot_qqplot_pago_total_cob,
             plot_qqplot_pago_total_cob_filtered_0.00,
             ncol=2)
```

\

**COSTE TOTAL COBERTURA**

```{r}
# Estadísticas descriptivas para coste_total_cob
stats_coste_total_cob <- LS_train %>%
  summarize(
    Minimo = round(min(coste_total_cob, na.rm = TRUE), 2),
    Maximo = round(max(coste_total_cob, na.rm = TRUE), 2),
    Mediana = round(median(coste_total_cob, na.rm = TRUE), 2),
    Media = round(mean(coste_total_cob, na.rm = TRUE), 2),
    Desviacion_Estandar = round(sd(coste_total_cob, na.rm = TRUE), 2),
    Varianza = round(var(coste_total_cob, na.rm = TRUE), 2),
    Q1 = round(quantile(coste_total_cob, 0.25, na.rm = TRUE), 2),
    Q3 = round(quantile(coste_total_cob, 0.75, na.rm = TRUE), 2)
  ) %>%
  mutate(
    Rango = round(Maximo - Minimo, 2),
    Rango_Intercuartilico = round(Q3 - Q1, 2)
  ) %>%
  gather("Estadístico", "Valor")

# Estadísticas descriptivas para coste_total_cob excluyendo 0.00
stats_coste_total_cob_sin_ceros <- LS_train %>%
  filter(coste_total_cob != 0.00) %>%
  summarize(
    Minimo = round(min(coste_total_cob, na.rm = TRUE), 2),
    Maximo = round(max(coste_total_cob, na.rm = TRUE), 2),
    Mediana = round(median(coste_total_cob, na.rm = TRUE), 2),
    Media = round(mean(coste_total_cob, na.rm = TRUE), 2),
    Desviacion_Estandar = round(sd(coste_total_cob, na.rm = TRUE), 2),
    Varianza = round(var(coste_total_cob, na.rm = TRUE), 2),
    Q1 = round(quantile(coste_total_cob, 0.25, na.rm = TRUE), 2),
    Q3 = round(quantile(coste_total_cob, 0.75, na.rm = TRUE), 2)
  ) %>%
  mutate(
    Rango = round(Maximo - Minimo, 2),
    Rango_Intercuartilico = round(Q3 - Q1, 2)
  ) %>%
  gather("Estadístico", "Valor_sin_ceros")

# Agregamos la moda como una fila adicional con 0.00 y sin 0.00
mode_value_coste_total_cob <- as.numeric(names(sort(table(LS_train$coste_total_cob), decreasing = TRUE)[1]))
stats_coste_total_cob <- rbind(stats_coste_total_cob, data.frame(Estadístico = "Moda", Valor = round(mode_value_coste_total_cob, 2)))

mode_value_coste_total_cob_sin_ceros <- as.numeric(names(sort(table(filter(LS_train, coste_total_cob != 0.00)$coste_total_cob), decreasing = TRUE)[1]))
stats_coste_total_cob_sin_ceros <- rbind(stats_coste_total_cob_sin_ceros, data.frame(Estadístico = "Moda", Valor_sin_ceros = round(mode_value_coste_total_cob_sin_ceros, 2)))

# Fusionamos las dos tablas
stats_coste_total_cob <- left_join(stats_coste_total_cob, stats_coste_total_cob_sin_ceros, by = "Estadístico")

# Convertir la tabla a kbl
tabla_coste_total_cob <- kbl(stats_coste_total_cob, align = c("c", "c", "c"), col.names = c("Estadístico", "Valor", "Valor sin 0.00")) %>%
  kable_material()

tabla_coste_total_cob
```

```{r}
# PLOT HISTOGRAMA COSTE TOTAL COBERTURA
plot_hist_dens_coste_total_cob <- ggplot(LS_train, aes(x=coste_total_cob)) +
		                     geom_histogram(aes(y=..density..), fill="#009494", bins=20) +
		                     geom_density(alpha=0.2, color="#D55E00") + 
		                     labs(title="Hist. y Dens. coste_total_cob", y="Densidad") +
		                     theme(plot.title = element_text(hjust = 0.5))



# PLOT BOXPLOT COSTE TOTAL COBERTURA
plot_boxplot_coste_total_cob <- ggplot(LS_train, aes(y=coste_total_cob)) +
		                   geom_boxplot(fill="#009494", outlier.color="#D55E00", outlier.shape=16, outlier.size=2) +
		                   labs(title="Boxplot coste_total_cob") +
		                   theme(plot.title = element_text(hjust = 0.5))



# PLOT SCATTERPLOT COSTE TOTAL COBERTURA
plot_geomplot_coste_total_cob <- ggplot(LS_train, aes(x=seq_along(coste_total_cob), y=coste_total_cob)) +
		                    geom_point(color="#009494", alpha=0.4) +
		                    labs(title="Scatter Plot coste_total_cob", x="Índice", y="Valor") +
		                    theme(plot.title = element_text(hjust = 0.5))



# PLOT QQPLOT COSTE TOTAL COBERTURA
plot_qqplot_coste_total_cob <- ggplot(LS_train, aes(sample=coste_total_cob)) +
		                  stat_qq(distribution=stats::qnorm, dparams=list(mean=mean(LS_train$coste_total_cob, na.rm=TRUE), sd=sd(LS_train$coste_total_cob, na.rm=TRUE))) +
		                  geom_abline(intercept=0, slope=1, color="#D55E00") +
		                  labs(title="Q-Q Plot coste_total_cob") +
		                  theme(plot.title = element_text(hjust = 0.5))



# Filtrar el dataset para excluir los valores de 0.00 en coste_total_cob
LS_train_filtered_coste_total_cob_0.00 <- LS_train %>% filter(coste_total_cob != 0.00)

# PLOT HISTOGRAMA COSTE TOTAL COBERTURA SIN 0.00
plot_hist_dens_coste_total_cob_filtered_0.00 <- ggplot(LS_train_filtered_coste_total_cob_0.00, aes(x=coste_total_cob)) +
                                                   geom_histogram(aes(y=..density..), fill="#009494", bins=20) +
                                                   geom_density(alpha=0.2, color="#D55E00") + 
                                                   labs(title="Hist. y Dens. coste_total_cob <> 0.00", y="Densidad") +
                                                   theme(plot.title = element_text(hjust = 0.5))



# PLOT BOXPLOT COSTE TOTAL COBERTURA SIN 0.00
plot_boxplot_coste_total_cob_filtered_0.00 <- ggplot(LS_train_filtered_coste_total_cob_0.00, aes(y=coste_total_cob)) +
                                                 geom_boxplot(fill="#009494", outlier.color="#D55E00", outlier.shape=16, outlier.size=2) +
                                                 labs(title="Boxplot coste_total_cob <> 0.00") +
                                                 theme(plot.title = element_text(hjust = 0.5))



# PLOT SCATTERPLOT COSTE TOTAL COBERTURA SIN 0.00
plot_geomplot_coste_total_cob_filtered_0.00 <- ggplot(LS_train_filtered_coste_total_cob_0.00, aes(x=seq_along(coste_total_cob), y=coste_total_cob)) +
                                                  geom_point(color="#009494", alpha=0.4) +
                                                  labs(title="Scatter Plot coste_total_cob <> 0.00", x="Índice", y="Valor") +
                                                  theme(plot.title = element_text(hjust = 0.5))



# PLOT QQPLOT COSTE TOTAL COBERTURA SIN 0.00
plot_qqplot_coste_total_cob_filtered_0.00 <- ggplot(LS_train_filtered_coste_total_cob_0.00, aes(sample=coste_total_cob)) +
                                                stat_qq(distribution=stats::qnorm, dparams=list(mean=mean(LS_train_filtered_coste_total_cob_0.00$coste_total_cob, na.rm=TRUE), sd=sd(LS_train_filtered_coste_total_cob_0.00$coste_total_cob, na.rm=TRUE))) +
                                                geom_abline(intercept=0, slope=1, color="#D55E00") +
                                                labs(title="Q-Q Plot coste_total_cob <> 0.00") +
                                                theme(plot.title = element_text(hjust = 0.5))
```

```{r}
grid.arrange(plot_hist_dens_coste_total_cob,
             plot_hist_dens_coste_total_cob_filtered_0.00,
             ncol=2)



grid.arrange(plot_boxplot_coste_total_cob,
             plot_boxplot_coste_total_cob_filtered_0.00,
             ncol=2)



grid.arrange(plot_geomplot_coste_total_cob,
             plot_geomplot_coste_total_cob_filtered_0.00,
             ncol=2)



grid.arrange(plot_qqplot_coste_total_cob,
             plot_qqplot_coste_total_cob_filtered_0.00,
             ncol=2)
```

\

**RESUMEN SINIESTROS**

```{r}
total_siniestros <- nrow(LS_train)



# Para prov_inicial_cob
cantidad_prov_inicial_0.00 <- nrow(LS_train %>% filter(prov_inicial_cob == 0.00))
porcentaje_prov_inicial_0.00 <- round((cantidad_prov_inicial_0.00 / total_siniestros) * 100, 2)

cantidad_prov_inicial_no_0.00 <- nrow(LS_train %>% filter(prov_inicial_cob != 0.00))
porcentaje_prov_inicial_no_0.00 <- round((cantidad_prov_inicial_no_0.00 / total_siniestros) * 100, 2)



# Para prov_cob
cantidad_prov_cob_0.00 <- nrow(LS_train %>% filter(prov_cob == 0.00))
porcentaje_prov_cob_0.00 <- round((cantidad_prov_cob_0.00 / total_siniestros) * 100, 2)

cantidad_prov_cob_no_0.00 <- nrow(LS_train %>% filter(prov_cob != 0.00))
porcentaje_prov_cob_no_0.00 <- round((cantidad_prov_cob_no_0.00 / total_siniestros) * 100, 2)



# Para pago_total_cob
cantidad_pago_total_0.00 <- nrow(LS_train %>% filter(pago_total_cob == 0.00))
porcentaje_pago_total_0.00 <- round((cantidad_pago_total_0.00 / total_siniestros) * 100, 2)

cantidad_pago_total_no_0.00 <- nrow(LS_train %>% filter(pago_total_cob != 0.00))
porcentaje_pago_total_no_0.00 <- round((cantidad_pago_total_no_0.00 / total_siniestros) * 100, 2)



# Para coste_total_cob
cantidad_coste_total_0.00 <- nrow(LS_train %>% filter(coste_total_cob == 0.00))
porcentaje_coste_total_0.00 <- round((cantidad_coste_total_0.00 / total_siniestros) * 100, 2)

cantidad_coste_total_no_0.00 <- nrow(LS_train %>% filter(coste_total_cob != 0.00))
porcentaje_coste_total_no_0.00 <- round((cantidad_coste_total_no_0.00 / total_siniestros) * 100, 2)



# Presentar los resultados
resumen_siniestros <- data.frame(
  Variable = c("prov_inicial_cob", "prov_cob", "pago_total_cob", "coste_total_cob"),
  Cantidad_0.00 = c(cantidad_prov_inicial_0.00, cantidad_prov_cob_0.00, cantidad_pago_total_0.00, cantidad_coste_total_0.00),
  Porcentaje_0.00 = c(porcentaje_prov_inicial_0.00, porcentaje_prov_cob_0.00, porcentaje_pago_total_0.00, porcentaje_coste_total_0.00),
  Cantidad_no_0.00 = c(cantidad_prov_inicial_no_0.00, cantidad_prov_cob_no_0.00, cantidad_pago_total_no_0.00, cantidad_coste_total_no_0.00),
  Porcentaje_no_0.00 = c(porcentaje_prov_inicial_no_0.00, porcentaje_prov_cob_no_0.00, porcentaje_pago_total_no_0.00, porcentaje_coste_total_no_0.00)
)

# Presentar los resultados en una tabla estilizada con kbl
resumen_siniestros_kbl <- kbl(resumen_siniestros, align = c("c", "c", "c", "c")) %>%
  kable_material()

resumen_siniestros_kbl
```

\

Las conclusiones que podemos sacar tras este análisis univariante cuantitativo son las siguientes:

-   Hay excasos registros que tengan 0.00€ de **provisión inicial**, apenas un 0.33%, y esto tiene sentido porque cuando se comunica un siniestro y se abre, siempre debe llevar aparejado un importe estimado de coste al que llamamos reserva o reserva inicial. En todo caso, los 240 siniestros cuyo importe de reserva inicial es 0.00€ son siniestros que se han aperturado mal y en su momento el tramitador cometió el error de no grabar ninguna reserva.
No apreciamos apenas diferencias en los estadísticos con zeros y sin ellos, así como el los gráficos que llevan aparejados. Vemos una gran cantidad de datos por debajo de los 130€ y luego diversos datos atípicos.

-   Respecto a la variable **provisión cobertura** si que hay diferencias significativas en los estadísticos si quitamos los zeros de los que no. El procentaje de siniestros con prov_cob 0.00 es del 90% lo que tiene bastante sentido si nos percatamos de que el mismo porcentaje de siniestros está cerrado. Esto es una máxima en el mundo de los seguros, todo siniestro abierto tiene que tener una provisión / reserva, y todo siniestro cerrado tiene que tener esta variable a 0, si no, sería una incongruencia.
La provisión media se sitúa en torno a los 230€ pero tiene una desviación estándar bastante alta. Hay diversos datos atípicos o también llamados siniestros punta por encima de los 2.000€.

-   En cuenta a la variable **pago total por cobertura** sucede lo mismo que con la anterior, existen diferencias entre eliminar los siniestros coste zero ya que aumenta el valor medio de las indemnizaciones de 125€ a más de 300€; y esto se debe a que en la bbdds actual casi un 60% de los siniestros no tienen pagos.

-   **Coste total por cobertura**: es el dato cuantitativo realmente relevante en este análisis ya que tiene en cuenta los pagos y reservas anteriores y revela cual será el coste real de un siniestro. Efectivamente al igual que sucede con prov_cob y pagos_total_cob, también hay diferencias entre considerar los siniestros zero y no considerarlos ya que la realidad de LS Insurance es que casi el 55% de los siniestros acaban siendo siniestros con coste 0.

\

**SINIESTROS PUNTA**

Dada la correlación lineal que existe entre prov_cob y pago_total_cob con coste_total_cob, y que es precisamente esta última sobre la que queremos predecir; vamos a hacer un pequeño análisis de datos atípicos sin tener en cuenta los siniestros coste 0 ni el siniestro negativo ya que sólo hay un dato así y es totalmente atípico, incñuso podría ser un error. 

Nos interesa realizar este análisis ya que como hemos podido observar en los gráficos de más arriba, hay una gran concentración de siniestros con coste alrededor de los 300€, pero también tenemos multitud de siniestros con coste por encima de los 1000€ que se podrían considerar como siniestros punta y que podrían distorsionar los modelos que iremos haciendo  conforme avance este estudio.

```{r}
# Filtrar el dataset para incluir solo los valores de coste_total_cob mayores a 0.00
LS_train_filtered_mayor0.00_outliers <- LS_train %>% filter(coste_total_cob > 0.00)

# Calcular Q1 y Q3 para coste_total_cob mayores a 0.00
Q1_mayor0.00 <- quantile(LS_train_filtered_mayor0.00_outliers$coste_total_cob, 0.25)
Q3_mayor0.00 <- quantile(LS_train_filtered_mayor0.00_outliers$coste_total_cob, 0.75)

# Calcular IQR
IQR <- Q3_mayor0.00 - Q1_mayor0.00

# Identificar límites para outliers
coste_total_cob_lower_bound <- Q1_mayor0.00 - 1.5 * IQR
coste_total_cob_upper_bound <- Q3_mayor0.00 + 1.5 * IQR

# coste_total_cob_lower_bound
coste_total_cob_upper_bound
```

\

Se puede entender entonces que cualquier siniestro de LS Insurance por encima de los 500€ es un siniestro punta. Vamos a ver cuantos siniestros tenemos por debajo y por encima de esa cifra.

```{r}
# Siniestros con coste_total_cob menor que 500.00
siniestros_menor_500 <- LS_train_filtered_mayor0.00_outliers %>% filter(coste_total_cob < 500.00) %>% nrow()

# Siniestros con coste_total_cob mayor o igual a 500.00
siniestros_mayor_o_igual_500 <- LS_train_filtered_mayor0.00_outliers %>% filter(coste_total_cob >= 500.00) %>% nrow()

cat(paste0("nº de siniestros coste_total_cob < 500€ es ", siniestros_menor_500), "\n")
cat(paste0("nº de siniestros coste_total_cob >= 500€ es ", siniestros_mayor_o_igual_500), "\n")
```


\
\

# Análisis multivariante



\
\

# Procesado de variables

\
\

# Modelo de regresión lineal

\
\

# Conclusiones preliminares

\
\

# Aprendizaje no supervisado

## K-Means

\
\

# Técnicas de reducción de la dimensionalidad

## PCA

\
\

# Aprendizaje supervisado

## GLM

## KNN

## DECISION TREES

## RANDOM FOREST

## SVM

\
\

# Evaluación y comparación de modelos

## K-fold Cross Validation

## N-fold Cross Validation

\
\

## Conclusiones

\

# Punto de corte ROC

\

# Deep Learning

\
\

# Explicabilidad

\
\

# Series Temporales


